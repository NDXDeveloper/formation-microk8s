üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.4 PersistentVolumeClaims (PVC)

## Introduction

Dans la section pr√©c√©dente, nous avons explor√© les PersistentVolumes (PV), qui repr√©sentent le stockage physique disponible dans un cluster Kubernetes. Maintenant, d√©couvrons les **PersistentVolumeClaims (PVC)**, qui sont la mani√®re dont les applications demandent et consomment ce stockage.

Un PVC est essentiellement une "demande" ou une "r√©clamation" de stockage. C'est le lien entre ce que les utilisateurs veulent (une certaine quantit√© de stockage avec certaines caract√©ristiques) et ce qui est disponible (les PV).

## Qu'est-ce qu'un PersistentVolumeClaim ?

### D√©finition

Un **PersistentVolumeClaim (PVC)** est :
- Une demande de stockage faite par un utilisateur ou une application
- Une ressource Kubernetes qui r√©serve un PersistentVolume
- Le moyen d'abstraction qui permet aux d√©veloppeurs de ne pas se soucier des d√©tails du stockage
- Une ressource namespaced (contrairement aux PV qui sont au niveau cluster)

**Analogie** : Si un PersistentVolume est un appartement disponible √† la location, un PersistentVolumeClaim est la demande de location que vous faites. Vous sp√©cifiez ce dont vous avez besoin (taille, caract√©ristiques), et le syst√®me trouve un appartement correspondant.

### La s√©paration des responsabilit√©s

C'est l'un des concepts cl√©s de Kubernetes :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  ADMINISTRATEUR                        ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ  ‚Ä¢ Configure le stockage physique                      ‚îÇ
‚îÇ  ‚Ä¢ Cr√©e les PersistentVolumes (ou configure            ‚îÇ
‚îÇ    le provisionnement dynamique)                       ‚îÇ
‚îÇ  ‚Ä¢ D√©finit les StorageClasses                          ‚îÇ
‚îÇ  ‚Ä¢ G√®re l'infrastructure de stockage                   ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ           ‚îÇ PersistentVolume ‚îÇ                         ‚îÇ
‚îÇ           ‚îÇ   (Offre)        ‚îÇ                         ‚îÇ
‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                    ‚îÇ                                   ‚îÇ
‚îÇ                    ‚îÇ  Binding                          ‚îÇ
‚îÇ                    ‚îÇ  (Kubernetes fait le lien)        ‚îÇ
‚îÇ                    ‚îÇ                                   ‚îÇ
‚îÇ           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ           ‚îÇ PersistentVolume ‚îÇ                         ‚îÇ
‚îÇ           ‚îÇ      Claim       ‚îÇ                         ‚îÇ
‚îÇ           ‚îÇ   (Demande)      ‚îÇ                         ‚îÇ
‚îÇ           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îÇ                    ‚îÇ                                   ‚îÇ
‚îÇ                  UTILISATEUR / D√âVELOPPEUR             ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ  ‚Ä¢ Cr√©e des PVC avec les besoins de l'application      ‚îÇ
‚îÇ  ‚Ä¢ Utilise les PVC dans les pods                       ‚îÇ
‚îÇ  ‚Ä¢ Ne se soucie pas de l'impl√©mentation du stockage    ‚îÇ
‚îÇ                                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avantages de cette s√©paration** :
- Les d√©veloppeurs n'ont pas besoin de conna√Ætre les d√©tails du stockage
- Le code des applications reste portable
- L'administrateur garde le contr√¥le du stockage
- Changement d'infrastructure plus facile

## Comment fonctionne le Binding ?

Le **binding** (liaison) est le processus par lequel Kubernetes associe un PVC √† un PV.

### Processus de binding

```
1. Cr√©ation du PVC
   ‚îÇ
   ‚ñº
2. Kubernetes recherche un PV disponible qui correspond
   ‚îÇ
   ‚îú‚îÄ Crit√®res de correspondance :
   ‚îÇ  ‚Ä¢ StorageClass identique (ou d√©faut)
   ‚îÇ  ‚Ä¢ Capacit√© suffisante (PV >= PVC)
   ‚îÇ  ‚Ä¢ Modes d'acc√®s compatibles
   ‚îÇ  ‚Ä¢ S√©lecteurs respect√©s
   ‚îÇ
   ‚ñº
3. Si PV trouv√© ‚Üí BINDING
   ‚îÇ
   ‚îú‚îÄ PV : Status = Bound
   ‚îî‚îÄ PVC : Status = Bound
   ‚îÇ
   ‚ñº
4. Si aucun PV trouv√©
   ‚îÇ
   ‚îú‚îÄ Provisionnement dynamique ?
   ‚îÇ  ‚îú‚îÄ OUI ‚Üí Cr√©ation automatique d'un PV
   ‚îÇ  ‚îî‚îÄ NON ‚Üí PVC reste en Pending
   ‚îÇ
   ‚ñº
5. Le PVC peut maintenant √™tre utilis√© dans un Pod
```

**Points importants** :
- Le binding est **exclusif** : un PV ne peut √™tre li√© qu'√† un seul PVC
- Le binding est **bidirectionnel** : PVC ‚Üî PV
- Une fois li√©, le PVC "poss√®de" le PV jusqu'√† sa suppression

## Anatomie d'un PersistentVolumeClaim

Examinons la structure compl√®te d'un manifeste PVC :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mon-pvc
  namespace: default
  labels:
    app: mon-app
  annotations:
    description: "Stockage pour ma base de donn√©es"
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: fast-storage
  selector:
    matchLabels:
      type: ssd
  volumeMode: Filesystem
```

D√©cortiquons chaque section :

### metadata : Identification du PVC

```yaml
metadata:
  name: mon-pvc              # Nom unique dans le namespace
  namespace: default         # Namespace (contrairement aux PV)
  labels:                    # Labels pour organisation
    app: mon-app
    environment: production
```

**Points cl√©s** :
- Le nom doit √™tre unique **dans le namespace**
- Les PVC sont des ressources namespac√©es (contrairement aux PV)
- Les labels facilitent la gestion et le filtrage

### accessModes : Modes d'acc√®s demand√©s

```yaml
spec:
  accessModes:
    - ReadWriteOnce
```

Le PVC demande des modes d'acc√®s sp√©cifiques. Les m√™mes que pour les PV :

| Mode | Abr√©viation | Description |
|------|-------------|-------------|
| ReadWriteOnce | RWO | Lecture-√©criture par un seul n≈ìud |
| ReadOnlyMany | ROX | Lecture seule par plusieurs n≈ìuds |
| ReadWriteMany | RWX | Lecture-√©criture par plusieurs n≈ìuds |
| ReadWriteOncePod | RWOP | Lecture-√©criture par un seul pod |

**Important** : Le PV li√© doit supporter au moins un des modes demand√©s.

#### Demander plusieurs modes

Vous pouvez sp√©cifier plusieurs modes, et Kubernetes choisira un PV qui en supporte au moins un :

```yaml
accessModes:
  - ReadWriteOnce
  - ReadOnlyMany
```

### resources.requests : Quantit√© de stockage demand√©e

```yaml
spec:
  resources:
    requests:
      storage: 10Gi
```

**Points importants** :
- C'est la taille minimale dont vous avez besoin
- Le PV li√© doit avoir **au moins** cette capacit√©
- Si le PV a plus, tant mieux (vous pourrez utiliser la capacit√© totale)
- Vous ne pouvez pas demander moins apr√®s cr√©ation

**Unit√©s de mesure** :
```yaml
storage: 1Ki    # 1024 bytes
storage: 1Mi    # 1024 Ki = 1 048 576 bytes
storage: 1Gi    # 1024 Mi = 1 073 741 824 bytes
storage: 1Ti    # 1024 Gi
```

#### Exemple de correspondance

```yaml
# PVC demande
resources:
  requests:
    storage: 5Gi

# PV disponible (10Gi) ‚Üí ‚úÖ Match
# Le PVC obtiendra les 10Gi complets
```

### storageClassName : Classe de stockage

```yaml
spec:
  storageClassName: fast-storage
```

La StorageClass d√©termine :
- Quel type de stockage sera utilis√©
- Comment le PV sera provisionn√© (dynamiquement ou non)
- Les caract√©ristiques du stockage (rapide, lent, r√©pliqu√©, etc.)

**Cas sp√©ciaux** :

```yaml
# Utiliser la StorageClass par d√©faut du cluster
storageClassName: ""    # Cha√Æne vide (pas omis)

# Laisser Kubernetes choisir automatiquement
# (Omis compl√®tement)
spec:
  accessModes: [...]
  # pas de storageClassName
```

**Comportements** :

| Configuration | Comportement |
|---------------|--------------|
| `storageClassName: "ma-classe"` | Utilise cette classe sp√©cifique |
| `storageClassName: ""` | PV sans classe uniquement |
| Champ omis | Utilise la classe par d√©faut |

### selector : S√©lectionner un PV sp√©cifique

Le `selector` permet de cibler des PV sp√©cifiques via leurs labels :

```yaml
spec:
  selector:
    matchLabels:
      type: ssd
      environment: production
```

**Utilit√©** :
- Contr√¥le plus fin sur quel PV sera utilis√©
- Peut cibler un PV sp√©cifique pr√©par√© √† l'avance
- Utile pour des besoins particuliers

#### Exemple complet de s√©lection

```yaml
# PV avec labels
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-ssd-fast
  labels:
    type: ssd
    speed: fast
    tier: premium
spec:
  capacity:
    storage: 100Gi
  accessModes:
    - ReadWriteOnce
  storageClassName: premium

---
# PVC qui cible ce PV
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-fast-storage
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 50Gi
  storageClassName: premium
  selector:
    matchLabels:
      type: ssd
      speed: fast
```

#### matchExpressions : S√©lection avanc√©e

Pour des crit√®res plus complexes :

```yaml
spec:
  selector:
    matchExpressions:
    - key: environment
      operator: In
      values:
      - production
      - staging
    - key: type
      operator: NotIn
      values:
      - test
```

**Op√©rateurs disponibles** :
- `In` : La valeur doit √™tre dans la liste
- `NotIn` : La valeur ne doit pas √™tre dans la liste
- `Exists` : La cl√© doit exister (peu importe la valeur)
- `DoesNotExist` : La cl√© ne doit pas exister

### volumeMode : Mode de volume

```yaml
spec:
  volumeMode: Filesystem    # ou Block
```

Doit correspondre au `volumeMode` du PV :
- `Filesystem` (d√©faut) : Syst√®me de fichiers mont√©
- `Block` : P√©riph√©rique bloc brut

### dataSource : Cloner ou restaurer

Fonctionnalit√© avanc√©e pour cr√©er un PVC depuis une source existante :

```yaml
spec:
  dataSource:
    name: mon-pvc-source
    kind: PersistentVolumeClaim
```

**Cas d'usage** :
- Cloner un PVC existant
- Restaurer depuis un snapshot
- Cr√©er des copies pour tests

## Exemples complets de PVC

### Exemple 1 : PVC simple et basique

Le plus simple possible, pour d√©buter :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-simple
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
```

**Ce qui se passe** :
- Demande 5 Gi de stockage
- Mode RWO (un seul n≈ìud)
- Utilise la StorageClass par d√©faut
- Kubernetes trouvera automatiquement un PV compatible

### Exemple 2 : PVC avec classe de stockage sp√©cifique

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-database
  namespace: production
  labels:
    app: postgresql
    tier: database
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
  storageClassName: fast-ssd
```

**Explications** :
- Demande 20 Gi
- Classe "fast-ssd" pour des performances √©lev√©es
- Labels pour identifier facilement
- Namespace production

### Exemple 3 : PVC avec s√©lecteur

Pour cibler un PV sp√©cifique :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-selective
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: manual
  selector:
    matchLabels:
      disk-type: ssd
      availability-zone: us-east-1a
```

**Utilit√©** :
- Garantit que le stockage sera sur un SSD
- Garantit la zone de disponibilit√©
- Utile pour optimisation des performances ou contraintes g√©ographiques

### Exemple 4 : PVC pour stockage partag√©

Pour plusieurs pods qui acc√®dent au m√™me stockage :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-shared-files
spec:
  accessModes:
    - ReadWriteMany      # Support multi-n≈ìuds
  resources:
    requests:
      storage: 50Gi
  storageClassName: nfs-storage
```

**Note** : ReadWriteMany n√©cessite un type de stockage qui le supporte (NFS, CephFS, etc.)

### Exemple 5 : PVC avec annotations

Pour documenter et ajouter des m√©tadonn√©es :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-documented
  annotations:
    description: "Stockage pour les uploads utilisateurs"
    owner: "team-backend@example.com"
    backup-policy: "daily"
    retention-days: "30"
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
  storageClassName: standard
```

## Utiliser un PVC dans un Pod

### M√©thode simple

Une fois le PVC cr√©√©, vous pouvez l'utiliser dans un pod :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-pvc
spec:
  containers:
  - name: app
    image: nginx:1.21
    volumeMounts:
    - name: persistent-storage    # Nom du volume dans le pod
      mountPath: /usr/share/nginx/html

  volumes:
  - name: persistent-storage      # D√©finition du volume
    persistentVolumeClaim:
      claimName: pvc-simple       # R√©f√©rence au PVC
```

**Processus** :
1. Le PVC doit exister et √™tre `Bound`
2. Le pod r√©f√©rence le PVC par son nom
3. Le volume est mont√© au chemin sp√©cifi√©
4. Les donn√©es √©crites dans `/usr/share/nginx/html` sont persistantes

### Avec un Deployment

Plus courant en production :

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-data
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
spec:
  replicas: 1    # Important : RWO = 1 seul replica
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: app
        image: myapp:1.0
        volumeMounts:
        - name: data
          mountPath: /data
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: app-data
```

**‚ö†Ô∏è Attention avec les Deployments et RWO** :
- Si `accessMode: ReadWriteOnce` et `replicas > 1`, les pods peuvent √©chouer
- Solution : Utiliser `ReadWriteMany` ou un StatefulSet

### Avec un StatefulSet

Pour des applications avec √©tat :

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:    # Cr√©e automatiquement un PVC par replica
  - metadata:
      name: data
    spec:
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 20Gi
      storageClassName: fast
```

**Avantage** : Chaque replica obtient son propre PVC automatiquement !

## Gestion des PVC

### Cr√©er un PVC

```bash
# Depuis un fichier YAML
microk8s kubectl apply -f mon-pvc.yaml

# V√©rifier la cr√©ation
microk8s kubectl get pvc
```

**R√©sultat attendu** :
```
NAME        STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS
mon-pvc     Bound    pvc-12345678-1234-1234-1234-123456789012  5Gi        RWO            microk8s-hostpath
```

**Statuts possibles** :
- `Pending` : En attente de binding avec un PV
- `Bound` : Li√© √† un PV, pr√™t √† √™tre utilis√©
- `Lost` : Le PV li√© a √©t√© supprim√© (rare)

### Lister les PVC

```bash
# Liste simple
microk8s kubectl get pvc

# Dans tous les namespaces
microk8s kubectl get pvc --all-namespaces

# Avec plus de d√©tails
microk8s kubectl get pvc -o wide

# Format personnalis√©
microk8s kubectl get pvc -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,VOLUME:.spec.volumeName,CAPACITY:.status.capacity.storage
```

### Voir les d√©tails d'un PVC

```bash
microk8s kubectl describe pvc mon-pvc
```

**Informations importantes** :
- **Status** : √âtat actuel
- **Volume** : PV li√© (si bound)
- **Capacity** : Capacit√© r√©ellement obtenue
- **Access Modes** : Modes d'acc√®s
- **StorageClass** : Classe utilis√©e
- **Events** : √âv√©nements r√©cents

**Exemple de sortie** :
```
Name:          mon-pvc
Namespace:     default
StorageClass:  microk8s-hostpath
Status:        Bound
Volume:        pvc-abc123...
Labels:        <none>
Capacity:      5Gi
Access Modes:  RWO
Events:
  Type    Reason                 Age   Message
  ----    ------                 ----  -------
  Normal  ProvisioningSucceeded  2m    Successfully provisioned volume
```

### Modifier un PVC

‚ö†Ô∏è **Limitations** : La plupart des champs ne peuvent pas √™tre modifi√©s apr√®s cr√©ation :
- `accessModes` : Immuable
- `storageClassName` : Immuable
- `selector` : Immuable
- `resources.requests.storage` : Ne peut qu'augmenter (avec expansion activ√©e)

**Modifications possibles** :
- Labels et annotations
- Augmentation de la capacit√© (si support√©)

### Expansion de volume

Si la StorageClass le permet, vous pouvez augmenter la taille :

```yaml
# PVC original
spec:
  resources:
    requests:
      storage: 10Gi

# Modification
spec:
  resources:
    requests:
      storage: 20Gi    # Augmentation
```

**Commande** :
```bash
microk8s kubectl edit pvc mon-pvc
# Modifier la valeur storage
```

**Conditions requises** :
- La StorageClass doit avoir `allowVolumeExpansion: true`
- Le type de stockage doit supporter l'expansion
- On peut seulement **augmenter**, jamais r√©duire

**V√©rifier si l'expansion est support√©e** :
```bash
microk8s kubectl get storageclass
```

Cherchez la colonne `ALLOWVOLUMEEXPANSION`.

### Supprimer un PVC

```bash
microk8s kubectl delete pvc mon-pvc
```

**Ce qui se passe** :
1. Le PVC est marqu√© pour suppression
2. Si un pod utilise le PVC, la suppression attend
3. Une fois lib√©r√©, le PVC est supprim√©
4. Le PV associ√© suit sa `reclaimPolicy` :
   - `Retain` : Le PV passe en "Released", donn√©es conserv√©es
   - `Delete` : Le PV et le stockage sont supprim√©s

**Forcer la suppression** (avec pr√©caution) :
```bash
microk8s kubectl delete pvc mon-pvc --force --grace-period=0
```

‚ö†Ô∏è **Attention** : Peut causer des probl√®mes si un pod utilise encore le PVC !

## √âtats et cycle de vie d'un PVC

### Diagramme du cycle de vie

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   PVC cr√©√©                          ‚îÇ
‚îÇ                      ‚îÇ                              ‚îÇ
‚îÇ                      ‚ñº                              ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                       ‚îÇ
‚îÇ              ‚îÇ   PENDING    ‚îÇ                       ‚îÇ
‚îÇ              ‚îÇ              ‚îÇ                       ‚îÇ
‚îÇ              ‚îÇ Recherche un ‚îÇ                       ‚îÇ
‚îÇ              ‚îÇ PV compatible‚îÇ                       ‚îÇ
‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ
‚îÇ                     ‚îÇ                               ‚îÇ
‚îÇ        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îÇ
‚îÇ        ‚îÇ                          ‚îÇ                 ‚îÇ
‚îÇ        ‚ñº                          ‚ñº                 ‚îÇ
‚îÇ  PV trouv√©                   Pas de PV              ‚îÇ
‚îÇ  ou cr√©√©                     disponible             ‚îÇ
‚îÇ        ‚îÇ                          ‚îÇ                 ‚îÇ
‚îÇ        ‚îÇ                          ‚îÇ                 ‚îÇ
‚îÇ        ‚ñº                          ‚ñº                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            Reste en PENDING           ‚îÇ
‚îÇ  ‚îÇ  BOUND   ‚îÇ            (Provisionnement           ‚îÇ
‚îÇ  ‚îÇ          ‚îÇ             dynamique tente           ‚îÇ
‚îÇ  ‚îÇ PVC pr√™t ‚îÇ             de cr√©er un PV)           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                       ‚îÇ
‚îÇ       ‚îÇ                                             ‚îÇ
‚îÇ       ‚îÇ PVC utilis√© par des pods                    ‚îÇ
‚îÇ       ‚îÇ                                             ‚îÇ
‚îÇ       ‚ñº                                             ‚îÇ
‚îÇ  Suppression du PVC                                 ‚îÇ
‚îÇ       ‚îÇ                                             ‚îÇ
‚îÇ       ‚ñº                                             ‚îÇ
‚îÇ  PV suit sa reclaimPolicy                           ‚îÇ
‚îÇ  ‚Ä¢ Retain ‚Üí PV Released                             ‚îÇ
‚îÇ  ‚Ä¢ Delete ‚Üí PV supprim√©                             ‚îÇ
‚îÇ                                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### √âtat PENDING : Pourquoi et que faire ?

**Causes courantes** :

1. **Aucun PV disponible**
   ```bash
   microk8s kubectl get pv
   # V√©rifier s'il y a des PV "Available"
   ```

2. **Aucun PV ne correspond aux crit√®res**
   - Capacit√© insuffisante
   - Modes d'acc√®s incompatibles
   - StorageClass diff√©rente
   - S√©lecteurs non satisfaits

3. **Provisionnement dynamique en cours**
   - Normal, attendez quelques secondes

4. **Provisionnement dynamique √©choue**
   ```bash
   microk8s kubectl describe pvc mon-pvc
   # Regarder la section Events
   ```

**Solutions** :
```bash
# V√©rifier les √©v√©nements
microk8s kubectl describe pvc mon-pvc

# V√©rifier la StorageClass
microk8s kubectl get storageclass

# V√©rifier les PV disponibles
microk8s kubectl get pv

# Pour MicroK8s, v√©rifier l'addon
microk8s status
# S'assurer que hostpath-storage est activ√©
```

## Protection et finalizers

### Protection contre la suppression

Kubernetes prot√®ge les PVC utilis√©s contre la suppression :

```bash
# Tenter de supprimer un PVC utilis√©
microk8s kubectl delete pvc mon-pvc
# Le PVC reste en √©tat "Terminating" jusqu'√† ce qu'aucun pod ne l'utilise
```

**V√©rifier quels pods utilisent un PVC** :
```bash
microk8s kubectl get pods -o json | jq -r '.items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName=="mon-pvc") | .metadata.name'
```

### Finalizers

Les finalizers sont des m√©canismes de protection :

```yaml
metadata:
  finalizers:
  - kubernetes.io/pvc-protection
```

**R√¥le** : Emp√™che la suppression du PVC tant qu'il est utilis√© par un pod.

**Supprimer les finalizers** (en dernier recours) :
```bash
microk8s kubectl patch pvc mon-pvc -p '{"metadata":{"finalizers":null}}'
```

‚ö†Ô∏è **Danger** : √Ä utiliser uniquement si vous √™tes certain que le PVC n'est plus utilis√© !

## Bonnes pratiques

### 1. Nommage coh√©rent et descriptif

```yaml
# Bon
metadata:
  name: postgres-data-prod
  name: webapp-uploads-staging
  name: redis-cache-dev

# √Ä √©viter
metadata:
  name: pvc1
  name: data
  name: storage
```

**Pattern recommand√©** : `<app>-<usage>-<environnement>`

### 2. Utiliser des labels

```yaml
metadata:
  name: mysql-data
  labels:
    app: mysql
    component: database
    environment: production
    managed-by: helm
```

**Avantages** :
- Facilite le filtrage et la recherche
- Permet l'automatisation
- Am√©liore la tra√ßabilit√©

### 3. Documenter avec des annotations

```yaml
metadata:
  annotations:
    description: "Base de donn√©es principale de production"
    backup-schedule: "0 2 * * *"
    owner: "team-data@example.com"
    cost-center: "engineering"
```

### 4. Demander la bonne quantit√©

```yaml
# Pr√©voyez de la marge pour la croissance
resources:
  requests:
    storage: 50Gi    # Si vous estimez 30Gi, demandez plus
```

**Conseils** :
- Estimez vos besoins √† 6-12 mois
- Ajoutez 30-50% de marge
- Surveillez l'utilisation r√©elle

### 5. Choisir le bon mode d'acc√®s

```yaml
# Pour une base de donn√©es (1 pod)
accessModes:
  - ReadWriteOnce

# Pour des fichiers statiques (plusieurs pods en lecture)
accessModes:
  - ReadOnlyMany

# Pour du partage actif (plusieurs pods en √©criture)
accessModes:
  - ReadWriteMany    # N√©cessite un stockage appropri√©
```

### 6. Utiliser le provisionnement dynamique

```yaml
# Pr√©f√©rez ceci (provisionnement dynamique)
spec:
  storageClassName: fast

# Plut√¥t que ceci (provisionnement statique)
spec:
  storageClassName: ""
  selector:
    matchLabels:
      specific-pv: "true"
```

**Sauf si** : Vous avez vraiment besoin d'un contr√¥le pr√©cis sur le PV utilis√©.

### 7. G√©rer par namespace

Organisez vos PVC par namespace pour une meilleure isolation :

```yaml
# Production
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-data
  namespace: production

---
# Staging
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-data
  namespace: staging
```

## Erreurs courantes et solutions

### Erreur 1 : PVC reste en PENDING ind√©finiment

**Sympt√¥me** :
```bash
$ microk8s kubectl get pvc
NAME      STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS
mon-pvc   Pending                                      fast-ssd
```

**Diagnostic** :
```bash
microk8s kubectl describe pvc mon-pvc
```

**Causes et solutions** :

#### a) Aucun PV disponible
```
Events:
  Type     Reason              Message
  ----     ------              -------
  Warning  ProvisioningFailed  no persistent volumes available
```

**Solution** : Cr√©er un PV manuellement ou activer le provisionnement dynamique.

#### b) StorageClass inexistante
```
Events:
  Warning  ProvisioningFailed  storageclass "fast-ssd" not found
```

**Solution** :
```bash
# V√©rifier les StorageClasses disponibles
microk8s kubectl get storageclass

# Corriger le PVC
microk8s kubectl edit pvc mon-pvc
# Changer storageClassName vers une classe existante
```

#### c) Provisionneur manquant
```
Events:
  Warning  ProvisioningFailed  Failed to provision volume: no provisioner found
```

**Solution pour MicroK8s** :
```bash
microk8s enable hostpath-storage
```

### Erreur 2 : PVC demande trop de stockage

**Sympt√¥me** :
```bash
$ microk8s kubectl get pvc
NAME      STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS
mon-pvc   Pending                                      standard
```

**Events** :
```
Warning  ProvisioningFailed  Failed to find PV with sufficient capacity
```

**Solution** :
```yaml
# R√©duire la demande ou cr√©er un PV plus grand
spec:
  resources:
    requests:
      storage: 5Gi    # Au lieu de 100Gi
```

### Erreur 3 : Modes d'acc√®s incompatibles

**Sympt√¥me** : Le PVC reste Pending malgr√© des PV disponibles.

**Cause** :
```yaml
# PVC demande
accessModes:
  - ReadWriteMany

# Mais les PV disponibles n'offrent que
accessModes:
  - ReadWriteOnce
```

**Solution** : Adapter les modes d'acc√®s ou utiliser un type de stockage supportant RWX.

### Erreur 4 : Impossible de supprimer un PVC

**Sympt√¥me** :
```bash
$ microk8s kubectl delete pvc mon-pvc
persistentvolumeclaim "mon-pvc" deleted
# Mais la commande ne se termine pas et le PVC reste
```

**Cause** : Un pod utilise encore le PVC.

**Solution** :
```bash
# 1. Trouver les pods utilisant le PVC
microk8s kubectl get pods -o json | \
  jq -r '.items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName=="mon-pvc") | .metadata.name'

# 2. Supprimer ces pods d'abord
microk8s kubectl delete pod <nom-pod>

# 3. Le PVC sera alors supprim√© automatiquement
```

### Erreur 5 : L'expansion de volume ne fonctionne pas

**Sympt√¥me** : Vous augmentez la taille dans le PVC mais rien ne change.

**Causes possibles** :

1. **StorageClass ne supporte pas l'expansion**
```bash
microk8s kubectl get storageclass
# V√©rifier ALLOWVOLUMEEXPANSION = true
```

2. **Le pod doit √™tre red√©marr√©**
Pour certains types de stockage, le pod doit √™tre supprim√© et recr√©√© pour que l'expansion prenne effet.

```bash
# Supprimer le pod
microk8s kubectl delete pod <nom-pod>
# Le pod se recr√©e automatiquement (si g√©r√© par un Deployment)
```

### Erreur 6 : PVC li√© au mauvais PV

**Sympt√¥me** : Le PVC se lie √† un PV non d√©sir√©.

**Cause** : Pas de s√©lecteur, Kubernetes choisit le premier PV compatible.

**Pr√©vention** :
```yaml
spec:
  selector:
    matchLabels:
      environment: production
      type: fast
```

**Solution si d√©j√† li√©** :
```bash
# 1. Supprimer le PVC
microk8s kubectl delete pvc mon-pvc

# 2. Ajouter un s√©lecteur
# 3. Recr√©er le PVC
microk8s kubectl apply -f mon-pvc-avec-selector.yaml
```

## Monitoring et observation

### V√©rifier l'utilisation du stockage

```bash
# Voir la capacit√© allou√©e
microk8s kubectl get pvc

# Pour voir l'utilisation r√©elle (n√©cessite metrics-server)
microk8s kubectl top pvc
```

### Voir les PVC par StorageClass

```bash
microk8s kubectl get pvc --all-namespaces -o custom-columns=\
NAME:.metadata.name,\
NAMESPACE:.metadata.namespace,\
STORAGECLASS:.spec.storageClassName,\
SIZE:.spec.resources.requests.storage
```

### Auditer tous les PVC

Script bash pratique :
```bash
#!/bin/bash
echo "PVC Status Report"
echo "================="
for ns in $(microk8s kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do
  echo "Namespace: $ns"
  microk8s kubectl get pvc -n $ns -o custom-columns=\
NAME:.metadata.name,\
STATUS:.status.phase,\
VOLUME:.spec.volumeName,\
CAPACITY:.status.capacity.storage,\
STORAGECLASS:.spec.storageClassName
  echo ""
done
```

### Alerting

Points √† surveiller :
- PVC en PENDING trop longtemps
- Utilisation proche de la capacit√©
- √âchecs de provisionnement r√©p√©t√©s

## Sc√©narios d'utilisation courants

### Sc√©nario 1 : Base de donn√©es stateful

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data
  labels:
    app: postgres
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
  storageClassName: fast-ssd
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
spec:
  serviceName: postgres
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:14
        env:
        - name: POSTGRES_DB
          value: mydb
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: postgres-data
```

### Sc√©nario 2 : Application web avec uploads

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: webapp-uploads
spec:
  accessModes:
    - ReadWriteMany    # Plusieurs pods peuvent √©crire
  resources:
    requests:
      storage: 50Gi
  storageClassName: nfs-storage
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3    # Plusieurs replicas possibles avec RWX
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
      - name: webapp
        image: mywebapp:1.0
        volumeMounts:
        - name: uploads
          mountPath: /app/uploads
      volumes:
      - name: uploads
        persistentVolumeClaim:
          claimName: webapp-uploads
```

### Sc√©nario 3 : Cache Redis

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-data
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: standard
---
apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  containers:
  - name: redis
    image: redis:7
    volumeMounts:
    - name: data
      mountPath: /data
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: redis-data
```

## R√©sum√© visuel : PVC vs PV

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DIFF√âRENCES                           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  PersistentVolume (PV)    ‚îÇ  PersistentVolumeClaim (PVC) ‚îÇ
‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÇ
‚îÇ                           ‚îÇ                              ‚îÇ
‚îÇ  ‚Ä¢ Cluster-wide           ‚îÇ  ‚Ä¢ Namespac√©                 ‚îÇ
‚îÇ  ‚Ä¢ Cr√©√© par admin         ‚îÇ  ‚Ä¢ Cr√©√© par utilisateur      ‚îÇ
‚îÇ  ‚Ä¢ Repr√©sente le stockage ‚îÇ  ‚Ä¢ Demande du stockage       ‚îÇ
‚îÇ    physique               ‚îÇ                              ‚îÇ
‚îÇ  ‚Ä¢ Offre de stockage      ‚îÇ  ‚Ä¢ Demande de stockage       ‚îÇ
‚îÇ  ‚Ä¢ Ind√©pendant des apps   ‚îÇ  ‚Ä¢ Utilis√© par les apps      ‚îÇ
‚îÇ                           ‚îÇ                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Commandes de diagnostic essentielles

```bash
# Liste des PVC
microk8s kubectl get pvc
microk8s kubectl get pvc --all-namespaces

# D√©tails d'un PVC
microk8s kubectl describe pvc <nom-pvc>

# Voir le PV li√©
microk8s kubectl get pvc <nom-pvc> -o jsonpath='{.spec.volumeName}'

# Voir les √©v√©nements
microk8s kubectl get events --field-selector involvedObject.name=<nom-pvc>

# Format YAML complet
microk8s kubectl get pvc <nom-pvc> -o yaml

# Voir l'utilisation (si metrics-server install√©)
microk8s kubectl top pvc

# Trouver les pods utilisant un PVC
microk8s kubectl get pods -o json | \
  jq -r '.items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName=="<nom-pvc>") | .metadata.name'
```

## Prochaines √©tapes

Maintenant que vous ma√Ætrisez les PersistentVolumeClaims, vous √™tes pr√™t pour :

- **Section 6.5** : StorageClasses - Configuration du provisionnement dynamique en d√©tail
- **Section 6.6** : Gestion des volumes persistants - Techniques avanc√©es
- **Section 6.7** : StatefulSets - Applications stateful avec stockage persistant
- **Section 6.8** : Exemples pratiques - D√©ploiement de bases de donn√©es et applications

## Conclusion

Les PersistentVolumeClaims sont le moyen par lequel vos applications demandent et utilisent du stockage persistant dans Kubernetes. Ils fournissent une abstraction simple qui cache la complexit√© de l'infrastructure de stockage sous-jacente.

**Les points essentiels** :

- Les PVC sont des **demandes** de stockage (les PV sont l'offre)
- Ils sont **namespac√©s** (contrairement aux PV)
- Le **binding** est automatique selon des crit√®res de correspondance
- Le provisionnement peut √™tre **statique** ou **dynamique**
- Les PVC sont **prot√©g√©s** contre la suppression tant qu'ils sont utilis√©s
- Avec MicroK8s, tout est simplifi√© gr√¢ce au provisionnement dynamique

La combinaison PV/PVC est l'une des abstractions les plus puissantes de Kubernetes, permettant aux d√©veloppeurs de se concentrer sur leurs applications sans se soucier des d√©tails du stockage physique.

---

**Points cl√©s √† retenir** :

‚úÖ **PVC** = Demande de stockage par l'utilisateur
‚úÖ **Namespac√©** = Isol√© par namespace
‚úÖ **Binding automatique** = Kubernetes trouve le PV correspondant
‚úÖ **Provisionnement dynamique** = Cr√©ation automatique de PV √† la demande
‚úÖ **Protection** = Impossible de supprimer un PVC utilis√©
‚úÖ **Expansion** = Possibilit√© d'augmenter la taille (si support√©)
‚úÖ **Simple avec MicroK8s** = Addon hostpath-storage pour le provisionnement dynamique
‚úÖ **Labels et annotations** = Essentiels pour une bonne gestion

‚è≠Ô∏è [StorageClasses](/06-stockage-persistant/05-storageclasses.md)
