üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.2 Volumes et Volume Mounts

## Introduction

Dans la section pr√©c√©dente, nous avons d√©couvert les concepts fondamentaux du stockage dans Kubernetes. Maintenant, il est temps de rentrer dans le concret et de comprendre comment utiliser les **Volumes** et les **Volume Mounts** dans vos pods.

Ces deux concepts sont les briques de base du stockage dans Kubernetes. Ma√Ætriser leur utilisation est essentiel pour toute application qui a besoin de conserver des donn√©es, partager des fichiers entre conteneurs, ou simplement stocker des logs et des fichiers de configuration.

## Rappel : Qu'est-ce qu'un Volume ?

Un **Volume** dans Kubernetes est un r√©pertoire accessible aux conteneurs d'un pod. Contrairement au syst√®me de fichiers d'un conteneur qui est √©ph√©m√®re, un volume a une dur√©e de vie li√©e au pod lui-m√™me (et non √† un conteneur individuel).

**Points importants √† retenir** :
- Un volume existe aussi longtemps que le pod existe
- Si un conteneur dans le pod red√©marre, le volume persiste
- Quand le pod est supprim√©, le volume l'est aussi (sauf pour certains types de volumes)
- Plusieurs conteneurs dans le m√™me pod peuvent partager le m√™me volume

## Qu'est-ce qu'un Volume Mount ?

Un **Volume Mount** est le lien qui connecte un volume √† un conteneur. Il d√©finit :
- **Quel volume** utiliser (r√©f√©rence au nom du volume)
- **O√π** monter ce volume dans le conteneur (le chemin, exemple : `/app/data`)
- **Comment** le monter (lecture seule ou lecture-√©criture)

**Analogie** : Si le volume est une cl√© USB, le volume mount est l'action de brancher cette cl√© sur votre ordinateur et de d√©cider dans quel dossier elle appara√Ætra.

## Anatomie d'un pod avec volumes

Voyons la structure g√©n√©rale d'un pod utilisant des volumes :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mon-pod
spec:
  containers:
  - name: mon-conteneur
    image: nginx:latest
    volumeMounts:          # Section Volume Mounts
    - name: mon-volume     # R√©f√©rence au volume
      mountPath: /app/data # O√π dans le conteneur

  volumes:                 # Section Volumes
  - name: mon-volume       # Nom du volume
    emptyDir: {}           # Type de volume
```

**Observation importante** : Notez qu'il y a deux sections distinctes :
1. `volumeMounts` dans la d√©finition du conteneur
2. `volumes` dans la sp√©cification du pod

Cette s√©paration permet de d√©finir un volume une fois et de le monter dans plusieurs conteneurs si n√©cessaire.

## Les diff√©rents types de volumes

Kubernetes propose de nombreux types de volumes. Nous allons explorer les plus courants, du plus simple au plus avanc√©.

### 1. emptyDir : Le volume temporaire

Le type `emptyDir` est le plus simple. Il cr√©e un r√©pertoire vide quand le pod d√©marre.

#### Caract√©ristiques
- **Cr√©√©** : Quand le pod est assign√© √† un n≈ìud
- **Supprim√©** : Quand le pod est retir√© du n≈ìud
- **Partag√©** : Entre tous les conteneurs du pod
- **Stockage** : Sur le disque du n≈ìud (ou en RAM avec `medium: Memory`)

#### Cas d'usage typiques
- Espace de travail temporaire pour des calculs
- Cache pour acc√©l√©rer des op√©rations
- Partage de donn√©es entre conteneurs dans le m√™me pod
- Espace pour des fichiers temporaires

#### Exemple basique

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-emptydir-simple
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    - name: cache-volume
      mountPath: /cache

  volumes:
  - name: cache-volume
    emptyDir: {}
```

**Explication** :
- Un volume nomm√© `cache-volume` est cr√©√© (type `emptyDir`)
- Il est mont√© dans le conteneur nginx au chemin `/cache`
- Tout fichier √©crit dans `/cache` sera stock√© dans ce volume
- Si le conteneur nginx red√©marre, les fichiers seront toujours l√†
- Si le pod est supprim√©, le volume et son contenu disparaissent

#### Exemple avec emptyDir en m√©moire

Pour des performances maximales, vous pouvez stocker l'emptyDir en RAM :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-emptydir-memory
spec:
  containers:
  - name: app
    image: busybox:1.35
    command: ['sh', '-c', 'while true; do date >> /memory/date.txt; sleep 5; done']
    volumeMounts:
    - name: memory-volume
      mountPath: /memory

  volumes:
  - name: memory-volume
    emptyDir:
      medium: Memory      # Stockage en RAM
      sizeLimit: 100Mi    # Limite de taille
```

**Points importants** :
- `medium: Memory` : Stocke les donn√©es en RAM (tr√®s rapide)
- `sizeLimit` : Limite la quantit√© de RAM utilisable
- Attention : La RAM est limit√©e, √† utiliser avec parcimonie
- Utile pour : caches temporaires, fichiers de travail n√©cessitant de hautes performances

#### Exemple de partage entre conteneurs

Un des usages les plus utiles d'emptyDir est le partage de donn√©es entre conteneurs :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-partage-fichiers
spec:
  containers:
  # Premier conteneur : g√©n√®re des logs
  - name: generateur-logs
    image: busybox:1.35
    command: ['sh', '-c', 'while true; do echo "Log: $(date)" >> /logs/app.log; sleep 10; done']
    volumeMounts:
    - name: logs-partages
      mountPath: /logs

  # Deuxi√®me conteneur : lit les logs
  - name: lecteur-logs
    image: busybox:1.35
    command: ['sh', '-c', 'while true; do tail -f /logs/app.log; sleep 30; done']
    volumeMounts:
    - name: logs-partages
      mountPath: /logs
      readOnly: true      # Lecture seule

  volumes:
  - name: logs-partages
    emptyDir: {}
```

**Ce qui se passe ici** :
- Le volume `logs-partages` est cr√©√©
- Le conteneur `generateur-logs` √©crit dans `/logs/app.log`
- Le conteneur `lecteur-logs` lit depuis `/logs/app.log`
- Les deux conteneurs voient le m√™me fichier
- Le lecteur est en mode `readOnly` pour √©viter les modifications accidentelles

### 2. hostPath : Acc√©der au syst√®me de fichiers du n≈ìud

Le type `hostPath` monte un fichier ou un r√©pertoire du syst√®me de fichiers du n≈ìud directement dans le pod.

#### Caract√©ristiques
- **Acc√®s direct** : Au syst√®me de fichiers du n≈ìud Kubernetes
- **Persistance** : Les donn√©es survivent au pod
- **Limitation** : Li√© √† un n≈ìud sp√©cifique (pas portable)
- **Risque** : Peut poser des probl√®mes de s√©curit√©

#### Avertissement important

‚ö†Ô∏è **hostPath est √† utiliser avec pr√©caution** :
- Les donn√©es sont li√©es √† un n≈ìud particulier
- Si le pod est replanifi√© sur un autre n≈ìud, il ne retrouvera pas ses donn√©es
- Peut cr√©er des failles de s√©curit√©
- D√©conseill√© en production (sauf cas tr√®s sp√©cifiques)

#### Cas d'usage appropri√©s
- Lab personnel avec un seul n≈ìud (comme avec MicroK8s)
- Acc√®s aux logs du n≈ìud
- Acc√®s au socket Docker ou containerd
- Outils de monitoring qui ont besoin d'acc√©der au syst√®me h√¥te

#### Exemple simple

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-hostpath-simple
spec:
  containers:
  - name: app
    image: nginx:1.21
    volumeMounts:
    - name: data-hote
      mountPath: /data

  volumes:
  - name: data-hote
    hostPath:
      path: /mnt/data           # Chemin sur le n≈ìud
      type: DirectoryOrCreate   # Cr√©e le r√©pertoire s'il n'existe pas
```

**Explication** :
- Le r√©pertoire `/mnt/data` du n≈ìud est mont√© dans le pod
- Il appara√Æt comme `/data` dans le conteneur
- `type: DirectoryOrCreate` : Kubernetes cr√©era le r√©pertoire s'il n'existe pas
- Les fichiers √©crits dans `/data` seront visibles sur le n≈ìud dans `/mnt/data`

#### Types de hostPath

Le param√®tre `type` permet de sp√©cifier ce que vous attendez :

| Type | Description |
|------|-------------|
| `DirectoryOrCreate` | R√©pertoire ; cr√©√© s'il n'existe pas |
| `Directory` | Le r√©pertoire doit d√©j√† exister |
| `FileOrCreate` | Fichier ; cr√©√© s'il n'existe pas |
| `File` | Le fichier doit d√©j√† exister |
| `Socket` | Socket UNIX qui doit exister |
| `CharDevice` | P√©riph√©rique caract√®re qui doit exister |
| `BlockDevice` | P√©riph√©rique bloc qui doit exister |

#### Exemple avec v√©rification de type

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-hostpath-fichier
spec:
  containers:
  - name: configurateur
    image: busybox:1.35
    command: ['sh', '-c', 'cat /config/app.conf && sleep 3600']
    volumeMounts:
    - name: fichier-config
      mountPath: /config/app.conf

  volumes:
  - name: fichier-config
    hostPath:
      path: /etc/mon-app/config.conf
      type: File    # Le fichier doit exister
```

**Utilit√©** : Le pod ne d√©marrera pas si le fichier n'existe pas, ce qui √©vite des erreurs silencieuses.

### 3. configMap : Configuration sous forme de volume

Un ConfigMap peut √™tre mont√© comme un volume, ce qui est tr√®s pratique pour injecter des fichiers de configuration.

#### Caract√©ristiques
- Chaque cl√© du ConfigMap devient un fichier
- Le nom de la cl√© = nom du fichier
- La valeur de la cl√© = contenu du fichier
- Lecture seule par d√©faut
- Peut √™tre mis √† jour sans recr√©er le pod

#### Exemple complet

Cr√©ons d'abord un ConfigMap :

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: config-nginx
data:
  nginx.conf: |
    server {
      listen 80;
      server_name localhost;
      location / {
        root /usr/share/nginx/html;
        index index.html;
      }
    }
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>Mon App</title></head>
    <body><h1>Configuration via ConfigMap</h1></body>
    </html>
```

Maintenant, utilisons-le dans un pod :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-avec-configmap
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    - name: config-volume
      mountPath: /etc/nginx/conf.d

  volumes:
  - name: config-volume
    configMap:
      name: config-nginx
```

**Ce qui se passe** :
- Le ConfigMap `config-nginx` contient 2 cl√©s : `nginx.conf` et `index.html`
- Ces cl√©s deviennent 2 fichiers dans `/etc/nginx/conf.d/`
- Nginx peut maintenant lire sa configuration depuis ces fichiers

#### Monter uniquement certaines cl√©s

Vous n'√™tes pas oblig√© de monter tout le ConfigMap :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-configmap-partiel
spec:
  containers:
  - name: app
    image: busybox:1.35
    command: ['sh', '-c', 'cat /config/nginx.conf && sleep 3600']
    volumeMounts:
    - name: config-volume
      mountPath: /config

  volumes:
  - name: config-volume
    configMap:
      name: config-nginx
      items:                    # S√©lectionner des cl√©s sp√©cifiques
      - key: nginx.conf         # Cl√© du ConfigMap
        path: nginx.conf        # Nom du fichier dans le volume
```

#### Sp√©cifier des permissions

```yaml
volumes:
- name: config-volume
  configMap:
    name: config-nginx
    defaultMode: 0644    # Permissions des fichiers (en octal)
```

### 4. secret : Donn√©es sensibles comme volume

Les Secrets fonctionnent de mani√®re similaire aux ConfigMaps, mais pour des donn√©es sensibles.

#### Exemple

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: credentials-db
type: Opaque
stringData:
  username: admin
  password: motdepasse-secret
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-avec-secret
spec:
  containers:
  - name: app
    image: busybox:1.35
    command: ['sh', '-c', 'cat /secrets/username && cat /secrets/password && sleep 3600']
    volumeMounts:
    - name: secret-volume
      mountPath: /secrets
      readOnly: true    # Important : toujours en lecture seule

  volumes:
  - name: secret-volume
    secret:
      secretName: credentials-db
      defaultMode: 0400    # Permissions restrictives
```

**Bonnes pratiques** :
- Toujours monter les secrets en `readOnly`
- Utiliser des permissions restrictives (`0400` ou `0440`)
- Ne jamais logger ou afficher le contenu des secrets
- Les secrets sont en base64, pas chiffr√©s (attention !)

### 5. persistentVolumeClaim : Stockage persistant

C'est le type de volume le plus important pour du stockage qui doit survivre au pod.

#### Exemple

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mon-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
---
apiVersion: v1
kind: Pod
metadata:
  name: pod-avec-pvc
spec:
  containers:
  - name: app
    image: nginx:1.21
    volumeMounts:
    - name: persistent-storage
      mountPath: /data

  volumes:
  - name: persistent-storage
    persistentVolumeClaim:
      claimName: mon-pvc    # R√©f√©rence au PVC
```

**Points cl√©s** :
- Le PVC doit exister avant le pod
- Le stockage survit √† la suppression du pod
- Les donn√©es restent accessibles si vous recr√©ez le pod
- Nous verrons les PVC en d√©tail dans la section 6.4

## Options des Volume Mounts

Les Volume Mounts ont plusieurs options importantes √† conna√Ætre.

### mountPath : Le chemin de destination

C'est le chemin dans le conteneur o√π le volume sera accessible :

```yaml
volumeMounts:
- name: mon-volume
  mountPath: /app/data    # Accessible dans le conteneur √† ce chemin
```

### subPath : Monter un sous-r√©pertoire

Parfois, vous ne voulez monter qu'une partie d'un volume :

```yaml
volumeMounts:
- name: mon-volume
  mountPath: /app/config.yaml
  subPath: config.yaml    # Monte uniquement ce fichier
```

**Cas d'usage** :
- Monter un seul fichier d'un ConfigMap sans √©craser un r√©pertoire entier
- Utiliser diff√©rentes parties d'un PVC pour diff√©rents conteneurs

#### Exemple pratique avec subPath

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-subpath-exemple
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    volumeMounts:
    # Monte uniquement nginx.conf
    - name: config-volume
      mountPath: /etc/nginx/nginx.conf
      subPath: nginx.conf
    # Monte uniquement default.conf
    - name: config-volume
      mountPath: /etc/nginx/conf.d/default.conf
      subPath: default.conf

  volumes:
  - name: config-volume
    configMap:
      name: nginx-configs
```

### readOnly : Protection contre les modifications

Emp√™che les √©critures dans le volume :

```yaml
volumeMounts:
- name: mon-volume
  mountPath: /data
  readOnly: true    # Aucune √©criture possible
```

**Quand l'utiliser** :
- Pour des configurations qui ne doivent jamais √™tre modifi√©es
- Pour des secrets
- Pour partager des donn√©es en lecture seule entre conteneurs

### mountPropagation : Propagation des montages

Option avanc√©e qui contr√¥le comment les montages sont propag√©s :

```yaml
volumeMounts:
- name: mon-volume
  mountPath: /data
  mountPropagation: HostToContainer
```

**Valeurs possibles** :
- `None` (d√©faut) : Pas de propagation
- `HostToContainer` : Les montages du host apparaissent dans le conteneur
- `Bidirectional` : Propagation bidirectionnelle

‚ö†Ô∏è **Usage avanc√©** : N√©cessaire seulement pour des cas tr√®s sp√©cifiques (comme des gestionnaires de volumes)

## Patterns courants d'utilisation

### Pattern 1 : S√©paration des conteneurs

Un conteneur g√©n√®re des donn√©es, un autre les traite :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: producer-consumer
spec:
  containers:
  # Producteur de donn√©es
  - name: producer
    image: busybox:1.35
    command: ['sh', '-c', 'while true; do echo "Data: $(date)" >> /shared/data.txt; sleep 5; done']
    volumeMounts:
    - name: shared-data
      mountPath: /shared

  # Consommateur de donn√©es
  - name: consumer
    image: busybox:1.35
    command: ['sh', '-c', 'tail -f /shared/data.txt']
    volumeMounts:
    - name: shared-data
      mountPath: /shared
      readOnly: true

  volumes:
  - name: shared-data
    emptyDir: {}
```

### Pattern 2 : Init Container avec volume

Un Init Container pr√©pare des donn√©es pour le conteneur principal :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-avec-init
spec:
  initContainers:
  - name: initializer
    image: busybox:1.35
    command: ['sh', '-c', 'echo "Donn√©es initiales" > /data/init.txt']
    volumeMounts:
    - name: data-volume
      mountPath: /data

  containers:
  - name: app
    image: busybox:1.35
    command: ['sh', '-c', 'cat /data/init.txt && sleep 3600']
    volumeMounts:
    - name: data-volume
      mountPath: /data

  volumes:
  - name: data-volume
    emptyDir: {}
```

**Utilit√©** :
- T√©l√©charger des d√©pendances
- Pr√©parer une configuration
- Initialiser une base de donn√©es

### Pattern 3 : Sidecar pour les logs

Un conteneur sidecar exporte les logs d'un conteneur principal :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-avec-sidecar-logs
spec:
  containers:
  # Application principale
  - name: app
    image: busybox:1.35
    command: ['sh', '-c', 'while true; do echo "Application log" >> /var/log/app.log; sleep 5; done']
    volumeMounts:
    - name: logs
      mountPath: /var/log

  # Sidecar pour exporter les logs
  - name: log-exporter
    image: busybox:1.35
    command: ['sh', '-c', 'tail -f /var/log/app.log']
    volumeMounts:
    - name: logs
      mountPath: /var/log
      readOnly: true

  volumes:
  - name: logs
    emptyDir: {}
```

### Pattern 4 : Configuration multi-sources

Combiner plusieurs sources de configuration :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-multi-config
spec:
  containers:
  - name: app
    image: nginx:1.21
    volumeMounts:
    # Configuration g√©n√©rale
    - name: config-general
      mountPath: /etc/config
    # Secrets
    - name: secrets
      mountPath: /etc/secrets
      readOnly: true
    # Donn√©es persistantes
    - name: data
      mountPath: /data

  volumes:
  - name: config-general
    configMap:
      name: app-config
  - name: secrets
    secret:
      secretName: app-secrets
  - name: data
    persistentVolumeClaim:
      claimName: app-data-pvc
```

## Bonnes pratiques

### 1. Nommage coh√©rent

Utilisez des noms descriptifs pour vos volumes :

```yaml
# Bon
volumes:
- name: nginx-config
- name: app-data
- name: shared-logs

# √Ä √©viter
volumes:
- name: vol1
- name: temp
- name: data
```

### 2. Documenter l'usage

Ajoutez des commentaires dans vos manifestes :

```yaml
volumeMounts:
- name: app-data
  mountPath: /data
  # Stockage persistant pour les uploads utilisateurs
```

### 3. Permissions appropri√©es

Pour les secrets et donn√©es sensibles :

```yaml
volumes:
- name: secret-data
  secret:
    secretName: api-keys
    defaultMode: 0400    # Lecture uniquement pour le propri√©taire
```

### 4. Utiliser readOnly quand possible

Prot√©gez vos donn√©es contre les modifications accidentelles :

```yaml
volumeMounts:
- name: config
  mountPath: /etc/config
  readOnly: true    # √âvite les modifications
```

### 5. Taille appropri√©e pour emptyDir

Si vous utilisez `medium: Memory`, limitez toujours la taille :

```yaml
volumes:
- name: cache
  emptyDir:
    medium: Memory
    sizeLimit: 100Mi    # Toujours sp√©cifier une limite
```

### 6. √âviter hostPath en production

```yaml
# OK pour un lab/dev
volumes:
- name: data
  hostPath:
    path: /mnt/data

# Mieux pour la production
volumes:
- name: data
  persistentVolumeClaim:
    claimName: app-data
```

## Erreurs courantes et solutions

### Erreur 1 : Volume mount √©choue

**Sympt√¥me** : Le pod ne d√©marre pas, √©tat `ContainerCreating`

```bash
microk8s kubectl describe pod mon-pod
```

Recherchez :
```
Warning  FailedMount  kubelet  MountVolume.SetUp failed for volume "XXX"
```

**Causes possibles** :
- Le nom du volume dans `volumeMounts` ne correspond pas au nom dans `volumes`
- Le PVC r√©f√©renc√© n'existe pas
- Le ConfigMap ou Secret r√©f√©renc√© n'existe pas
- Type hostPath avec un chemin qui n'existe pas (et type non-create)

**Solution** : V√©rifiez la correspondance des noms et l'existence des ressources r√©f√©renc√©es.

### Erreur 2 : Permissions insuffisantes

**Sympt√¥me** : Le conteneur ne peut pas √©crire dans le volume

```
Permission denied when writing to /data
```

**Causes** :
- Le volume est mont√© en `readOnly`
- Les permissions du volume ne correspondent pas √† l'utilisateur du conteneur
- Pour hostPath : permissions incorrectes sur le n≈ìud

**Solution** :
```yaml
# V√©rifier readOnly
volumeMounts:
- name: data
  mountPath: /data
  readOnly: false    # Ou supprimer cette ligne (false par d√©faut)

# Ajuster les permissions pour secrets/configMaps
volumes:
- name: config
  configMap:
    name: app-config
    defaultMode: 0644    # Lecture pour tous, √©criture pour propri√©taire
```

### Erreur 3 : Conflit de subPath

**Sympt√¥me** : Le fichier ou r√©pertoire n'est pas visible

**Cause** : Mauvaise utilisation de `subPath`

```yaml
# Incorrect : subPath pointe vers un fichier qui n'existe pas
volumeMounts:
- name: config
  mountPath: /app/config.yaml
  subPath: fichier-inexistant.yaml
```

**Solution** : V√©rifier que le subPath existe dans la source.

### Erreur 4 : Donn√©es perdues avec emptyDir

**Sympt√¥me** : Les donn√©es disparaissent apr√®s un red√©ploiement

**Cause** : emptyDir est √©ph√©m√®re, li√© au cycle de vie du pod

**Solution** : Utiliser un PersistentVolumeClaim pour les donn√©es importantes :

```yaml
volumes:
- name: data
  persistentVolumeClaim:
    claimName: important-data
```

## Commandes utiles pour diagnostiquer

### V√©rifier les volumes d'un pod

```bash
microk8s kubectl describe pod <nom-pod>
```

Recherchez les sections :
- `Mounts:` dans la description du conteneur
- `Volumes:` dans la description du pod

### Voir le contenu d'un volume

```bash
# Acc√©der au conteneur
microk8s kubectl exec -it <nom-pod> -- /bin/sh

# Puis lister le contenu du volume
ls -la /chemin/vers/volume
```

### V√©rifier les permissions

```bash
microk8s kubectl exec <nom-pod> -- ls -la /chemin/vers/volume
```

### Tester l'√©criture dans un volume

```bash
microk8s kubectl exec <nom-pod> -- touch /chemin/vers/volume/test.txt
```

## R√©sum√© visuel des types de volumes

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Types de Volumes                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ  emptyDir                                                   ‚îÇ
‚îÇ  ‚îî‚îÄ Temporaire, li√© au pod                                  ‚îÇ
‚îÇ     ‚îî‚îÄ Usage : cache, partage entre conteneurs              ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  hostPath                                                   ‚îÇ
‚îÇ  ‚îî‚îÄ Acc√®s direct au n≈ìud                                    ‚îÇ
‚îÇ     ‚îî‚îÄ Usage : lab/dev, acc√®s syst√®me (prudence)            ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  configMap                                                  ‚îÇ
‚îÇ  ‚îî‚îÄ Configuration sous forme de fichiers                    ‚îÇ
‚îÇ     ‚îî‚îÄ Usage : fichiers de config, templates                ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  secret                                                     ‚îÇ
‚îÇ  ‚îî‚îÄ Donn√©es sensibles sous forme de fichiers                ‚îÇ
‚îÇ     ‚îî‚îÄ Usage : credentials, certificats, cl√©s API           ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  persistentVolumeClaim                                      ‚îÇ
‚îÇ  ‚îî‚îÄ Stockage persistant ind√©pendant du pod                  ‚îÇ
‚îÇ     ‚îî‚îÄ Usage : bases de donn√©es, fichiers permanents        ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## R√©capitulatif : Volume vs Volume Mount

**Volume** (dans `spec.volumes`) :
- D√©finit **QUOI** : quel stockage utiliser
- D√©finit **D'O√ô** vient le stockage
- D√©finit le **TYPE** de stockage
- D√©fini une seule fois au niveau du pod

**Volume Mount** (dans `spec.containers[].volumeMounts`) :
- D√©finit **O√ô** dans le conteneur
- D√©finit **COMMENT** le monter (readOnly, subPath, etc.)
- Peut √™tre d√©fini diff√©remment pour chaque conteneur
- R√©f√©rence un volume d√©fini dans `spec.volumes`

## Prochaines √©tapes

Maintenant que vous ma√Ætrisez les volumes et volume mounts, vous √™tes pr√™t √† explorer :

- **Section 6.3** : PersistentVolumes (PV) - Le stockage physique dans Kubernetes
- **Section 6.4** : PersistentVolumeClaims (PVC) - Comment demander du stockage
- **Section 6.5** : StorageClasses - Le provisionnement dynamique
- **Section 6.6** : Gestion avanc√©e des volumes persistants
- **Section 6.7** : StatefulSets - Applications avec √©tat n√©cessitant du stockage

## Conclusion

Les volumes et volume mounts sont les fondations du stockage dans Kubernetes. Comprendre leur fonctionnement est essentiel pour :

- Partager des donn√©es entre conteneurs
- Injecter de la configuration dans vos applications
- G√©rer des secrets de mani√®re s√©curis√©e
- Pr√©parer le terrain pour le stockage persistant

Avec MicroK8s, ces concepts sont particuli√®rement simples √† mettre en pratique gr√¢ce √† l'environnement de lab unifi√©. Dans les prochaines sections, nous construirons sur ces bases pour impl√©menter du stockage persistant robuste et professionnel.

---

**Points cl√©s √† retenir** :

‚úÖ **Volumes** : D√©finissent le stockage au niveau du pod
‚úÖ **Volume Mounts** : Lient les volumes aux conteneurs
‚úÖ **emptyDir** : Simple et temporaire, parfait pour le partage
‚úÖ **hostPath** : Acc√®s au n≈ìud, √† utiliser avec prudence
‚úÖ **configMap/secret** : Configuration et donn√©es sensibles sous forme de volumes
‚úÖ **persistentVolumeClaim** : Pour du stockage vraiment persistant
‚úÖ **subPath** : Permet de monter seulement une partie d'un volume
‚úÖ **readOnly** : Protection importante pour configurations et secrets

‚è≠Ô∏è [PersistentVolumes (PV)](/06-stockage-persistant/03-persistentvolumes-pv.md)
