üîù Retour au [Sommaire](/SOMMAIRE.md)

# 6.6 Gestion des volumes persistants

## Introduction

Nous avons maintenant une compr√©hension solide des concepts fondamentaux du stockage dans Kubernetes : les volumes, les PersistentVolumes (PV), les PersistentVolumeClaims (PVC) et les StorageClasses. Mais comprendre les concepts n'est que la premi√®re √©tape. Dans un environnement r√©el, vous devez √™tre capable de **g√©rer** activement ces ressources au quotidien.

Cette section couvre les aspects op√©rationnels et pratiques de la gestion du stockage persistant :
- Comment surveiller l'utilisation du stockage
- Comment effectuer des sauvegardes et restaurations
- Comment redimensionner les volumes
- Comment migrer des donn√©es
- Comment nettoyer et maintenir votre infrastructure de stockage
- Comment diagnostiquer et r√©soudre les probl√®mes courants

Que vous g√©riez un environnement de d√©veloppement local avec MicroK8s ou un cluster de production, ces comp√©tences sont essentielles.

## Vue d'ensemble de la gestion du stockage

### Le cycle de vie complet

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  CYCLE DE VIE DU STOCKAGE                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  1. PROVISIONNEMENT                                      ‚îÇ
‚îÇ     ‚îú‚îÄ Cr√©ation de StorageClass                          ‚îÇ
‚îÇ     ‚îú‚îÄ Cr√©ation de PVC                                   ‚îÇ
‚îÇ     ‚îî‚îÄ Provisionnement automatique du PV                 ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  2. UTILISATION                                          ‚îÇ
‚îÇ     ‚îú‚îÄ Montage dans les pods                             ‚îÇ
‚îÇ     ‚îú‚îÄ Lecture/√©criture des donn√©es                      ‚îÇ
‚îÇ     ‚îî‚îÄ Monitoring de l'utilisation                       ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  3. MAINTENANCE                                          ‚îÇ
‚îÇ     ‚îú‚îÄ Surveillance de la capacit√©                       ‚îÇ
‚îÇ     ‚îú‚îÄ Expansion si n√©cessaire                           ‚îÇ
‚îÇ     ‚îú‚îÄ Sauvegardes r√©guli√®res                            ‚îÇ
‚îÇ     ‚îî‚îÄ V√©rification de l'int√©grit√©                       ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  4. MIGRATION (si n√©cessaire)                            ‚îÇ
‚îÇ     ‚îú‚îÄ Copie des donn√©es                                 ‚îÇ
‚îÇ     ‚îú‚îÄ Changement de classe de stockage                  ‚îÇ
‚îÇ     ‚îî‚îÄ D√©placement entre namespaces                      ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  5. D√âCOMMISSIONNEMENT                                   ‚îÇ
‚îÇ     ‚îú‚îÄ Sauvegarde finale                                 ‚îÇ
‚îÇ     ‚îú‚îÄ Suppression du PVC                                ‚îÇ
‚îÇ     ‚îú‚îÄ R√©cup√©ration selon la politique                   ‚îÇ
‚îÇ     ‚îî‚îÄ Nettoyage du stockage physique                    ‚îÇ
‚îÇ                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Responsabilit√©s de gestion

**T√¢ches quotidiennes** :
- Monitoring de l'utilisation de l'espace
- V√©rification des alertes
- R√©ponse aux demandes de stockage

**T√¢ches hebdomadaires** :
- Revue de l'utilisation globale
- V√©rification des sauvegardes
- Nettoyage des ressources inutilis√©es

**T√¢ches mensuelles** :
- Analyse des tendances de croissance
- Planification de la capacit√©
- Audit de s√©curit√© du stockage

**T√¢ches trimestrielles** :
- Tests de restauration
- R√©vision des politiques
- Optimisation des co√ªts

## Monitoring et observation

### Surveiller l'utilisation du stockage

#### 1. √âtat global des PVC

```bash
# Lister tous les PVC
microk8s kubectl get pvc --all-namespaces

# Avec plus de d√©tails
microk8s kubectl get pvc --all-namespaces -o wide

# Format personnalis√©
microk8s kubectl get pvc --all-namespaces -o custom-columns=\
NAMESPACE:.metadata.namespace,\
NAME:.metadata.name,\
STATUS:.status.phase,\
CAPACITY:.status.capacity.storage,\
STORAGECLASS:.spec.storageClassName,\
AGE:.metadata.creationTimestamp
```

**R√©sultat exemple** :
```
NAMESPACE    NAME           STATUS   CAPACITY   STORAGECLASS       AGE
production   postgres-data  Bound    20Gi       microk8s-hostpath  30d
production   redis-cache    Bound    5Gi        microk8s-hostpath  30d
staging      app-data       Bound    10Gi       microk8s-hostpath  15d
```

#### 2. √âtat des PV

```bash
# Lister tous les PV
microk8s kubectl get pv

# Avec d√©tails sur le claim
microk8s kubectl get pv -o custom-columns=\
NAME:.metadata.name,\
CAPACITY:.spec.capacity.storage,\
STATUS:.status.phase,\
CLAIM:.spec.claimRef.name,\
STORAGECLASS:.spec.storageClassName,\
AGE:.metadata.creationTimestamp
```

#### 3. Utilisation r√©elle de l'espace disque

Pour MicroK8s avec hostpath-storage, v√©rifier directement sur le n≈ìud :

```bash
# Voir l'utilisation du r√©pertoire de stockage par d√©faut
du -sh /var/snap/microk8s/common/default-storage/*

# Version d√©taill√©e
du -h --max-depth=1 /var/snap/microk8s/common/default-storage/ | sort -hr
```

**R√©sultat exemple** :
```
15G     /var/snap/microk8s/common/default-storage/production-postgres-data-pvc-abc123
3.2G    /var/snap/microk8s/common/default-storage/production-redis-cache-pvc-def456
1.5G    /var/snap/microk8s/common/default-storage/staging-app-data-pvc-ghi789
```

#### 4. Script de monitoring complet

Cr√©ons un script bash pour surveiller l'utilisation :

```bash
#!/bin/bash
# monitoring-storage.sh

echo "==================================="
echo "   RAPPORT STOCKAGE KUBERNETES"
echo "==================================="
echo ""

echo "1. R√©sum√© des PVC par namespace"
echo "--------------------------------"
microk8s kubectl get pvc --all-namespaces --no-headers | \
  awk '{ns[$1]++} END {for (n in ns) print n": "ns[n]" PVC"}'
echo ""

echo "2. Espace total allou√©"
echo "----------------------"
total=$(microk8s kubectl get pvc --all-namespaces -o json | \
  jq -r '.items[].spec.resources.requests.storage' | \
  sed 's/Gi//' | awk '{sum+=$1} END {print sum}')
echo "Total: ${total}Gi"
echo ""

echo "3. PVC par √©tat"
echo "---------------"
microk8s kubectl get pvc --all-namespaces --no-headers | \
  awk '{status[$3]++} END {for (s in status) print s": "status[s]}'
echo ""

echo "4. Top 5 des plus gros PVC"
echo "--------------------------"
microk8s kubectl get pvc --all-namespaces -o json | \
  jq -r '.items | sort_by(.spec.resources.requests.storage) | reverse | .[:5] | .[] | "\(.metadata.namespace)/\(.metadata.name): \(.spec.resources.requests.storage)"'
echo ""

echo "5. Utilisation du disque physique (hostpath)"
echo "---------------------------------------------"
df -h /var/snap/microk8s/common/default-storage 2>/dev/null || echo "Chemin non accessible"
echo ""

echo "6. Alertes"
echo "----------"
# PVC en Pending
pending=$(microk8s kubectl get pvc --all-namespaces --no-headers | grep Pending | wc -l)
if [ $pending -gt 0 ]; then
  echo "‚ö†Ô∏è  $pending PVC en √©tat Pending"
  microk8s kubectl get pvc --all-namespaces | grep Pending
else
  echo "‚úÖ Aucun PVC en attente"
fi
echo ""
```

**Utilisation** :
```bash
chmod +x monitoring-storage.sh
./monitoring-storage.sh
```

#### 5. Monitoring avec Prometheus (avanc√©)

Si vous avez Prometheus install√© :

```bash
# Activer Prometheus sur MicroK8s
microk8s enable prometheus
```

**M√©triques importantes √† surveiller** :
- `kubelet_volume_stats_capacity_bytes` : Capacit√© totale
- `kubelet_volume_stats_used_bytes` : Espace utilis√©
- `kubelet_volume_stats_available_bytes` : Espace disponible
- `kubelet_volume_stats_inodes_used` : Inodes utilis√©s

**Exemple de requ√™te PromQL** :
```promql
# Pourcentage d'utilisation par PVC
(kubelet_volume_stats_used_bytes / kubelet_volume_stats_capacity_bytes) * 100
```

### Alertes et notifications

#### D√©finir des seuils d'alerte

**Seuils recommand√©s** :
- ‚ö†Ô∏è Warning : 70% d'utilisation
- üö® Critical : 85% d'utilisation
- üî¥ Emergency : 95% d'utilisation

#### Script d'alerte simple

```bash
#!/bin/bash
# alert-storage.sh

THRESHOLD=80  # Pourcentage

# V√©rifier l'utilisation du disque
usage=$(df /var/snap/microk8s/common/default-storage | tail -1 | awk '{print $5}' | sed 's/%//')

if [ $usage -gt $THRESHOLD ]; then
  echo "üö® ALERTE: Stockage √† ${usage}% d'utilisation (seuil: ${THRESHOLD}%)"

  # Lister les plus gros volumes
  echo "Plus gros consommateurs:"
  du -sh /var/snap/microk8s/common/default-storage/* | sort -hr | head -5

  # Envoyer une notification (exemple avec mail)
  # echo "Stockage critique: ${usage}%" | mail -s "Alerte Stockage K8s" admin@example.com
else
  echo "‚úÖ Stockage OK: ${usage}% d'utilisation"
fi
```

## Expansion de volumes

### V√©rifier si l'expansion est support√©e

```bash
# V√©rifier la StorageClass
microk8s kubectl get storageclass microk8s-hostpath -o yaml | grep allowVolumeExpansion
```

**R√©sultat attendu** :
```yaml
allowVolumeExpansion: true
```

### Augmenter la taille d'un PVC

#### M√©thode 1 : Via kubectl edit

```bash
# √âditer le PVC
microk8s kubectl edit pvc mon-pvc

# Modifier la ligne storage
# Avant:
#   storage: 10Gi
# Apr√®s:
#   storage: 20Gi
```

#### M√©thode 2 : Via kubectl patch

```bash
# Augmenter la taille √† 20Gi
microk8s kubectl patch pvc mon-pvc -p '{"spec":{"resources":{"requests":{"storage":"20Gi"}}}}'
```

#### M√©thode 3 : Via fichier YAML

```yaml
# pvc-expanded.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mon-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi    # Nouvelle taille
  storageClassName: microk8s-hostpath
```

```bash
microk8s kubectl apply -f pvc-expanded.yaml
```

### Processus d'expansion

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              PROCESSUS D'EXPANSION DE VOLUME             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  1. Modification du PVC                                  ‚îÇ
‚îÇ     ‚îî‚îÄ Augmentation de spec.resources.requests.storage   ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  2. Kubernetes d√©tecte le changement                     ‚îÇ
‚îÇ     ‚îî‚îÄ Condition PVCResizing ajout√©e                     ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  3. Expansion du volume sous-jacent                      ‚îÇ
‚îÇ     ‚îú‚îÄ Provisioner √©tend le stockage physique            ‚îÇ
‚îÇ     ‚îî‚îÄ Peut prendre quelques secondes/minutes            ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  4. Expansion du syst√®me de fichiers                     ‚îÇ
‚îÇ     ‚îú‚îÄ Automatique pour certains types                   ‚îÇ
‚îÇ     ‚îú‚îÄ N√©cessite red√©marrage du pod pour d'autres        ‚îÇ
‚îÇ     ‚îî‚îÄ Condition FileSystemResizePending si besoin       ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ  5. Expansion termin√©e                                   ‚îÇ
‚îÇ     ‚îú‚îÄ PVC refl√®te la nouvelle taille                    ‚îÇ
‚îÇ     ‚îî‚îÄ Condition PVCResizing supprim√©e                   ‚îÇ
‚îÇ                                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### V√©rifier le statut de l'expansion

```bash
# Voir l'√©tat du PVC
microk8s kubectl get pvc mon-pvc

# Voir les conditions d√©taill√©es
microk8s kubectl describe pvc mon-pvc
```

**Rechercher** :
```
Conditions:
  Type                      Status
  ----                      ------
  FileSystemResizePending   True    # Red√©marrage du pod n√©cessaire
  Resizing                  True    # Expansion en cours
```

### Red√©marrer le pod si n√©cessaire

Pour certains types de stockage, le pod doit √™tre red√©marr√© :

```bash
# Supprimer le pod (sera recr√©√© par le Deployment/StatefulSet)
microk8s kubectl delete pod <nom-pod>

# Ou faire un rollout restart
microk8s kubectl rollout restart deployment/<nom-deployment>
```

### Limitations de l'expansion

**Points importants** :
- ‚ùå On ne peut jamais **r√©duire** la taille
- ‚úÖ On peut seulement **augmenter**
- ‚ö†Ô∏è Certains syst√®mes n√©cessitent un red√©marrage du pod
- ‚ö†Ô∏è L'expansion peut prendre du temps selon le type de stockage
- ‚ö†Ô∏è Tous les provisioners ne supportent pas l'expansion

## Sauvegardes et restaurations

### Strat√©gies de sauvegarde

#### Strat√©gie 1 : Sauvegarde au niveau du pod

Copier les donn√©es depuis un pod vers un emplacement externe :

```bash
# Cr√©er une archive des donn√©es
microk8s kubectl exec <pod-name> -- tar czf /tmp/backup.tar.gz /data

# Copier l'archive localement
microk8s kubectl cp <pod-name>:/tmp/backup.tar.gz ./backup-$(date +%Y%m%d).tar.gz

# Nettoyer
microk8s kubectl exec <pod-name> -- rm /tmp/backup.tar.gz
```

#### Strat√©gie 2 : Sauvegarde au niveau du n≈ìud

Acc√©der directement au stockage sur le n≈ìud :

```bash
# Pour MicroK8s avec hostpath
# Identifier le r√©pertoire du PVC
PVC_DIR=$(microk8s kubectl get pv <pv-name> -o jsonpath='{.spec.hostPath.path}')

# Cr√©er une archive
sudo tar czf backup-$(date +%Y%m%d).tar.gz -C $PVC_DIR .

# Copier vers un emplacement s√ªr
sudo mv backup-*.tar.gz /backup/location/
```

#### Strat√©gie 3 : Snapshot de volume (avanc√©)

Certains provisioners supportent les snapshots :

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: mon-pvc-snapshot
spec:
  volumeSnapshotClassName: csi-snapclass
  source:
    persistentVolumeClaimName: mon-pvc
```

**Note** : N√©cessite un driver CSI supportant les snapshots.

### Script de sauvegarde automatis√©

```bash
#!/bin/bash
# backup-pvc.sh

# Configuration
NAMESPACE=$1
PVC_NAME=$2
BACKUP_DIR="/backup/k8s-volumes"
DATE=$(date +%Y%m%d-%H%M%S)

if [ -z "$NAMESPACE" ] || [ -z "$PVC_NAME" ]; then
  echo "Usage: $0 <namespace> <pvc-name>"
  exit 1
fi

echo "üîµ D√©marrage de la sauvegarde: $NAMESPACE/$PVC_NAME"

# Trouver un pod utilisant ce PVC
POD=$(microk8s kubectl get pods -n $NAMESPACE -o json | \
  jq -r ".items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName==\"$PVC_NAME\") | .metadata.name" | head -1)

if [ -z "$POD" ]; then
  echo "‚ùå Aucun pod trouv√© utilisant ce PVC"
  exit 1
fi

echo "üì¶ Pod trouv√©: $POD"

# Trouver le point de montage
MOUNT_PATH=$(microk8s kubectl get pod $POD -n $NAMESPACE -o json | \
  jq -r ".spec.containers[0].volumeMounts[] | select(.name==(\"$PVC_NAME\" | split(\"-\") | .[0])) | .mountPath")

if [ -z "$MOUNT_PATH" ]; then
  MOUNT_PATH="/data"  # D√©faut
fi

echo "üìÇ Chemin de montage: $MOUNT_PATH"

# Cr√©er le r√©pertoire de backup
mkdir -p "$BACKUP_DIR"

# Cr√©er l'archive
BACKUP_FILE="$BACKUP_DIR/${NAMESPACE}-${PVC_NAME}-${DATE}.tar.gz"
echo "üíæ Cr√©ation de l'archive..."

microk8s kubectl exec $POD -n $NAMESPACE -- tar czf - $MOUNT_PATH | cat > $BACKUP_FILE

if [ $? -eq 0 ]; then
  SIZE=$(du -h $BACKUP_FILE | cut -f1)
  echo "‚úÖ Sauvegarde termin√©e: $BACKUP_FILE ($SIZE)"
else
  echo "‚ùå Erreur lors de la sauvegarde"
  exit 1
fi

# Afficher les 5 derni√®res sauvegardes
echo ""
echo "üìã Derni√®res sauvegardes de ${NAMESPACE}/${PVC_NAME}:"
ls -lht "$BACKUP_DIR/${NAMESPACE}-${PVC_NAME}"* 2>/dev/null | head -5
```

**Utilisation** :
```bash
chmod +x backup-pvc.sh
./backup-pvc.sh production postgres-data
```

### Restauration depuis une sauvegarde

#### M√©thode 1 : Restauration dans un pod existant

```bash
# 1. Arr√™ter l'application (si n√©cessaire)
microk8s kubectl scale deployment/mon-app --replicas=0

# 2. Copier l'archive dans le pod temporaire
cat backup-20240101.tar.gz | microk8s kubectl exec -i temp-pod -- tar xzf - -C /data

# 3. Red√©marrer l'application
microk8s kubectl scale deployment/mon-app --replicas=1
```

#### M√©thode 2 : Restauration au niveau du n≈ìud

```bash
# 1. Identifier le r√©pertoire PV
PVC_DIR=$(microk8s kubectl get pv <pv-name> -o jsonpath='{.spec.hostPath.path}')

# 2. Vider le r√©pertoire actuel (ATTENTION !)
sudo rm -rf $PVC_DIR/*

# 3. Extraire la sauvegarde
sudo tar xzf backup-20240101.tar.gz -C $PVC_DIR

# 4. V√©rifier les permissions
sudo chown -R 1000:1000 $PVC_DIR  # Ajuster selon les besoins
```

#### M√©thode 3 : Restauration dans un nouveau PVC

```yaml
# 1. Cr√©er un nouveau PVC
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: restored-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
  storageClassName: microk8s-hostpath
---
# 2. Pod temporaire pour restaurer
apiVersion: v1
kind: Pod
metadata:
  name: restore-pod
spec:
  containers:
  - name: restore
    image: busybox:1.35
    command: ['sleep', '3600']
    volumeMounts:
    - name: data
      mountPath: /data
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: restored-pvc
```

```bash
# 3. Appliquer
microk8s kubectl apply -f restore-pod.yaml

# 4. Copier l'archive dans le pod
microk8s kubectl cp backup-20240101.tar.gz restore-pod:/tmp/

# 5. Extraire dans le volume
microk8s kubectl exec restore-pod -- tar xzf /tmp/backup-20240101.tar.gz -C /data

# 6. V√©rifier
microk8s kubectl exec restore-pod -- ls -la /data

# 7. Nettoyer le pod temporaire
microk8s kubectl delete pod restore-pod
```

### Planification automatique des sauvegardes

Utiliser un CronJob Kubernetes :

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-postgres
spec:
  schedule: "0 2 * * *"    # Tous les jours √† 2h du matin
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: busybox:1.35
            command:
            - /bin/sh
            - -c
            - |
              echo "Backup starting at $(date)"
              tar czf /backup/postgres-$(date +%Y%m%d).tar.gz -C /data .
              echo "Backup completed"
              # Nettoyer les backups > 7 jours
              find /backup -name "postgres-*.tar.gz" -mtime +7 -delete
            volumeMounts:
            - name: data
              mountPath: /data
              readOnly: true
            - name: backup
              mountPath: /backup
          restartPolicy: OnFailure
          volumes:
          - name: data
            persistentVolumeClaim:
              claimName: postgres-data
          - name: backup
            hostPath:
              path: /backup/kubernetes
              type: DirectoryOrCreate
```

## Migration de donn√©es

### Cas d'usage de migration

**Sc√©narios courants** :
1. Changement de StorageClass (ex: standard ‚Üí fast)
2. Migration entre namespaces
3. Redimensionnement non support√© par expansion
4. Changement de type de stockage (hostPath ‚Üí NFS)
5. Migration entre clusters

### Migration basique : Nouveau PVC dans le m√™me namespace

#### √âtape 1 : Cr√©er le nouveau PVC

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: new-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 30Gi    # Nouvelle taille
  storageClassName: fast    # Nouvelle classe
```

```bash
microk8s kubectl apply -f new-pvc.yaml
```

#### √âtape 2 : Pod de migration

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: migration-pod
spec:
  containers:
  - name: migrator
    image: busybox:1.35
    command: ['sleep', '3600']
    volumeMounts:
    - name: source
      mountPath: /source
      readOnly: true
    - name: destination
      mountPath: /destination
  volumes:
  - name: source
    persistentVolumeClaim:
      claimName: old-pvc
  - name: destination
    persistentVolumeClaim:
      claimName: new-pvc
```

```bash
microk8s kubectl apply -f migration-pod.yaml
```

#### √âtape 3 : Copier les donn√©es

```bash
# Copier avec tar (pr√©serve les permissions)
microk8s kubectl exec migration-pod -- sh -c 'tar cf - -C /source . | tar xf - -C /destination'

# Ou avec cp (plus simple mais peut perdre certains attributs)
microk8s kubectl exec migration-pod -- cp -av /source/. /destination/

# V√©rifier
microk8s kubectl exec migration-pod -- du -sh /source
microk8s kubectl exec migration-pod -- du -sh /destination
```

#### √âtape 4 : Mettre √† jour l'application

```bash
# Arr√™ter l'ancienne application
microk8s kubectl scale deployment/mon-app --replicas=0

# Modifier le deployment pour utiliser le nouveau PVC
microk8s kubectl patch deployment mon-app -p '
{
  "spec": {
    "template": {
      "spec": {
        "volumes": [{
          "name": "data",
          "persistentVolumeClaim": {
            "claimName": "new-pvc"
          }
        }]
      }
    }
  }
}'

# Red√©marrer
microk8s kubectl scale deployment/mon-app --replicas=1

# V√©rifier
microk8s kubectl get pods
microk8s kubectl logs -f deployment/mon-app
```

#### √âtape 5 : Nettoyer

```bash
# Supprimer le pod de migration
microk8s kubectl delete pod migration-pod

# Apr√®s v√©rification que tout fonctionne, supprimer l'ancien PVC
microk8s kubectl delete pvc old-pvc
```

### Migration entre namespaces

```bash
#!/bin/bash
# migrate-pvc-namespace.sh

SOURCE_NS="staging"
DEST_NS="production"
PVC_NAME="app-data"

echo "Migration: $SOURCE_NS/$PVC_NAME ‚Üí $DEST_NS/$PVC_NAME"

# 1. Cr√©er le namespace destination si n√©cessaire
microk8s kubectl create namespace $DEST_NS --dry-run=client -o yaml | microk8s kubectl apply -f -

# 2. Exporter la d√©finition du PVC
microk8s kubectl get pvc $PVC_NAME -n $SOURCE_NS -o yaml | \
  sed "s/namespace: $SOURCE_NS/namespace: $DEST_NS/" | \
  sed '/uid:/d' | sed '/resourceVersion:/d' | sed '/selfLink:/d' > temp-pvc.yaml

# 3. Cr√©er le nouveau PVC
microk8s kubectl apply -f temp-pvc.yaml

# 4. Cr√©er un pod de migration
cat <<EOF | microk8s kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: migration-pod
  namespace: $SOURCE_NS
spec:
  containers:
  - name: migrator
    image: busybox:1.35
    command: ['sleep', '3600']
    volumeMounts:
    - name: source
      mountPath: /source
  volumes:
  - name: source
    persistentVolumeClaim:
      claimName: $PVC_NAME
EOF

# Attendre que le pod soit pr√™t
microk8s kubectl wait --for=condition=ready pod/migration-pod -n $SOURCE_NS --timeout=60s

# 5. Cr√©er une archive
microk8s kubectl exec migration-pod -n $SOURCE_NS -- tar czf /tmp/data.tar.gz -C /source .

# 6. Copier localement
microk8s kubectl cp $SOURCE_NS/migration-pod:/tmp/data.tar.gz ./migration-data.tar.gz

# 7. Cr√©er un pod dans le namespace destination
cat <<EOF | microk8s kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: restore-pod
  namespace: $DEST_NS
spec:
  containers:
  - name: restore
    image: busybox:1.35
    command: ['sleep', '3600']
    volumeMounts:
    - name: dest
      mountPath: /dest
  volumes:
  - name: dest
    persistentVolumeClaim:
      claimName: $PVC_NAME
EOF

# Attendre
microk8s kubectl wait --for=condition=ready pod/restore-pod -n $DEST_NS --timeout=60s

# 8. Copier et extraire
microk8s kubectl cp ./migration-data.tar.gz $DEST_NS/restore-pod:/tmp/data.tar.gz
microk8s kubectl exec restore-pod -n $DEST_NS -- tar xzf /tmp/data.tar.gz -C /dest

# 9. V√©rifier
echo "Source:"
microk8s kubectl exec migration-pod -n $SOURCE_NS -- du -sh /source
echo "Destination:"
microk8s kubectl exec restore-pod -n $DEST_NS -- du -sh /dest

# 10. Nettoyer
microk8s kubectl delete pod migration-pod -n $SOURCE_NS
microk8s kubectl delete pod restore-pod -n $DEST_NS
rm -f migration-data.tar.gz temp-pvc.yaml

echo "‚úÖ Migration termin√©e"
```

## Nettoyage et maintenance

### Identifier les ressources inutilis√©es

#### PVC non utilis√©s par aucun pod

```bash
#!/bin/bash
# find-unused-pvcs.sh

echo "PVC non utilis√©s par aucun pod:"
echo "================================"

for ns in $(microk8s kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do
  pvcs=$(microk8s kubectl get pvc -n $ns -o jsonpath='{.items[*].metadata.name}')

  for pvc in $pvcs; do
    # Chercher des pods utilisant ce PVC
    used=$(microk8s kubectl get pods -n $ns -o json | \
      jq -r ".items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName==\"$pvc\") | .metadata.name" | wc -l)

    if [ $used -eq 0 ]; then
      size=$(microk8s kubectl get pvc $pvc -n $ns -o jsonpath='{.spec.resources.requests.storage}')
      age=$(microk8s kubectl get pvc $pvc -n $ns -o jsonpath='{.metadata.creationTimestamp}')
      echo "  $ns/$pvc ($size) - Cr√©√©: $age"
    fi
  done
done
```

#### PV en statut Released

```bash
# Lister les PV Released
microk8s kubectl get pv | grep Released

# Avec d√©tails
microk8s kubectl get pv -o json | \
  jq -r '.items[] | select(.status.phase=="Released") | "\(.metadata.name) - \(.spec.capacity.storage)"'
```

### Nettoyer les PV Released

```bash
#!/bin/bash
# cleanup-released-pv.sh

echo "Nettoyage des PV en statut Released"
echo "===================================="

# Lister les PV Released
released_pvs=$(microk8s kubectl get pv -o json | \
  jq -r '.items[] | select(.status.phase=="Released") | .metadata.name')

if [ -z "$released_pvs" ]; then
  echo "‚úÖ Aucun PV √† nettoyer"
  exit 0
fi

echo "PV √† nettoyer:"
echo "$released_pvs"
echo ""

read -p "Voulez-vous continuer? (oui/non) " -r
if [[ ! $REPLY =~ ^[Oo]ui$ ]]; then
  echo "Annul√©"
  exit 0
fi

for pv in $released_pvs; do
  echo "Traitement de $pv..."

  # R√©cup√©rer le chemin hostPath (si applicable)
  path=$(microk8s kubectl get pv $pv -o jsonpath='{.spec.hostPath.path}')

  if [ ! -z "$path" ]; then
    echo "  Chemin: $path"

    # Sauvegarder si n√©cessaire
    read -p "  Sauvegarder les donn√©es? (oui/non) " -r
    if [[ $REPLY =~ ^[Oo]ui$ ]]; then
      backup_file="backup-$pv-$(date +%Y%m%d).tar.gz"
      sudo tar czf $backup_file -C $path .
      echo "  ‚úÖ Sauvegarde: $backup_file"
    fi

    # Nettoyer le r√©pertoire
    read -p "  Supprimer les donn√©es? (oui/non) " -r
    if [[ $REPLY =~ ^[Oo]ui$ ]]; then
      sudo rm -rf $path/*
      echo "  ‚úÖ Donn√©es supprim√©es"
    fi
  fi

  # Supprimer le PV
  microk8s kubectl delete pv $pv
  echo "  ‚úÖ PV supprim√©"
  echo ""
done

echo "‚úÖ Nettoyage termin√©"
```

### Optimisation de l'espace disque

#### Supprimer les fichiers temporaires dans les volumes

```bash
#!/bin/bash
# cleanup-temp-files.sh

NAMESPACE=$1
PVC_NAME=$2

if [ -z "$NAMESPACE" ] || [ -z "$PVC_NAME" ]; then
  echo "Usage: $0 <namespace> <pvc-name>"
  exit 1
fi

# Trouver un pod utilisant le PVC
POD=$(microk8s kubectl get pods -n $NAMESPACE -o json | \
  jq -r ".items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName==\"$PVC_NAME\") | .metadata.name" | head -1)

if [ -z "$POD" ]; then
  echo "‚ùå Aucun pod trouv√©"
  exit 1
fi

echo "Nettoyage des fichiers temporaires dans $NAMESPACE/$PVC_NAME"

# Supprimer les fichiers temporaires courants
microk8s kubectl exec $POD -n $NAMESPACE -- find /data -type f \( -name "*.tmp" -o -name "*.temp" -o -name "*.log.old" \) -delete

# Supprimer les vieux logs (>30 jours)
microk8s kubectl exec $POD -n $NAMESPACE -- find /data -type f -name "*.log" -mtime +30 -delete

echo "‚úÖ Nettoyage termin√©"
```

### Rotation et compression des logs

Si vos applications g√©n√®rent beaucoup de logs dans les volumes :

```bash
#!/bin/bash
# compress-old-logs.sh

NAMESPACE=$1
PVC_NAME=$2
LOG_DIR="/data/logs"

POD=$(microk8s kubectl get pods -n $NAMESPACE -o json | \
  jq -r ".items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName==\"$PVC_NAME\") | .metadata.name" | head -1)

# Compresser les logs > 7 jours
microk8s kubectl exec $POD -n $NAMESPACE -- \
  find $LOG_DIR -type f -name "*.log" -mtime +7 ! -name "*.gz" -exec gzip {} \;

# Supprimer les logs compress√©s > 90 jours
microk8s kubectl exec $POD -n $NAMESPACE -- \
  find $LOG_DIR -type f -name "*.log.gz" -mtime +90 -delete

echo "‚úÖ Rotation des logs termin√©e"
```

## Diagnostic et d√©pannage

### V√©rifier l'int√©grit√© des donn√©es

#### Test de lecture/√©criture

```bash
# Cr√©er un pod de test
cat <<EOF | microk8s kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: test
    image: busybox:1.35
    command: ['sleep', '3600']
    volumeMounts:
    - name: test-vol
      mountPath: /test
  volumes:
  - name: test-vol
    persistentVolumeClaim:
      claimName: mon-pvc
EOF

# Test d'√©criture
microk8s kubectl exec volume-test -- sh -c 'echo "test" > /test/testfile.txt'

# Test de lecture
microk8s kubectl exec volume-test -- cat /test/testfile.txt

# V√©rifier les permissions
microk8s kubectl exec volume-test -- ls -la /test

# Test de performance (√©criture)
microk8s kubectl exec volume-test -- dd if=/dev/zero of=/test/testfile bs=1M count=100

# Nettoyer
microk8s kubectl exec volume-test -- rm /test/testfile*
microk8s kubectl delete pod volume-test
```

### Probl√®mes courants et solutions

#### Probl√®me 1 : "No space left on device"

**Sympt√¥mes** :
```
Error: no space left on device
```

**Diagnostic** :
```bash
# V√©rifier l'utilisation du disque
df -h /var/snap/microk8s/common/default-storage

# Identifier les gros fichiers
du -sh /var/snap/microk8s/common/default-storage/* | sort -hr | head -10
```

**Solutions** :
1. Nettoyer les fichiers inutiles
2. √âtendre le PVC si possible
3. Ajouter de l'espace disque au n≈ìud
4. Migrer vers un volume plus grand

#### Probl√®me 2 : "Permission denied"

**Sympt√¥mes** :
```
Error: permission denied writing to /data
```

**Diagnostic** :
```bash
# V√©rifier les permissions dans le volume
microk8s kubectl exec <pod> -- ls -la /data
```

**Solutions** :
```bash
# Option 1: Ajuster les permissions via un init container
apiVersion: v1
kind: Pod
metadata:
  name: mon-pod
spec:
  initContainers:
  - name: fix-permissions
    image: busybox:1.35
    command: ['sh', '-c', 'chmod -R 777 /data']
    volumeMounts:
    - name: data
      mountPath: /data
  containers:
  - name: app
    image: mon-app
    volumeMounts:
    - name: data
      mountPath: /data
  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: mon-pvc
```

```bash
# Option 2: Ajuster directement sur le n≈ìud
sudo chown -R 1000:1000 /var/snap/microk8s/common/default-storage/<pv-dir>
```

#### Probl√®me 3 : PVC bloqu√© en "Terminating"

**Sympt√¥mes** :
```bash
$ microk8s kubectl delete pvc mon-pvc
# La commande ne se termine pas
$ microk8s kubectl get pvc
NAME      STATUS        VOLUME   CAPACITY   ACCESS MODES
mon-pvc   Terminating   pvc-xxx  10Gi       RWO
```

**Diagnostic** :
```bash
# Trouver les pods utilisant le PVC
microk8s kubectl get pods -o json | \
  jq -r '.items[] | select(.spec.volumes[]?.persistentVolumeClaim.claimName=="mon-pvc") | .metadata.name'
```

**Solutions** :
```bash
# 1. Supprimer les pods utilisant le PVC
microk8s kubectl delete pod <pod-utilisant-pvc>

# 2. Si √ßa ne suffit pas, supprimer les finalizers
microk8s kubectl patch pvc mon-pvc -p '{"metadata":{"finalizers":null}}'
```

#### Probl√®me 4 : Corruption de donn√©es

**Sympt√¥mes** :
- Erreurs de lecture incoh√©rentes
- Application qui crash de mani√®re al√©atoire
- Fichiers corrompus

**Diagnostic** :
```bash
# V√©rifier le syst√®me de fichiers (n√©cessite d'arr√™ter le pod)
# Pour hostPath sur le n≈ìud
sudo fsck /dev/<device>

# V√©rifier les logs syst√®me
sudo journalctl -u snap.microk8s.daemon-kubelite | grep -i error
```

**Solutions** :
1. Restaurer depuis une sauvegarde
2. Recr√©er le PVC avec de nouvelles donn√©es
3. V√©rifier le hardware sous-jacent

## Automatisation avec des outils

### Utiliser kubectl plugins

#### krew : Gestionnaire de plugins kubectl

```bash
# Installation de krew
(
  set -x; cd "$(mktemp -d)" &&
  OS="$(uname | tr '[:upper:]' '[:lower:]')" &&
  ARCH="$(uname -m | sed -e 's/x86_64/amd64/' -e 's/\(arm\)\(64\)\?.*/\1\2/' -e 's/aarch64$/arm64/')" &&
  KREW="krew-${OS}_${ARCH}" &&
  curl -fsSLO "https://github.com/kubernetes-sigs/krew/releases/latest/download/${KREW}.tar.gz" &&
  tar zxvf "${KREW}.tar.gz" &&
  ./"${KREW}" install krew
)

# Ajouter au PATH
export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"
```

#### Plugins utiles pour le stockage

```bash
# df-pv : Voir l'utilisation des PV
kubectl krew install df-pv
kubectl df-pv

# view-utilization : Voir l'utilisation des ressources
kubectl krew install view-utilization
kubectl view-utilization

# resource-capacity : Capacit√© par n≈ìud
kubectl krew install resource-capacity
kubectl resource-capacity
```

### Scripts de maintenance automatis√©s

#### Script quotidien

```bash
#!/bin/bash
# daily-storage-maintenance.sh

LOG_FILE="/var/log/k8s-storage-maintenance.log"

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

log "========================================="
log "D√©but de la maintenance quotidienne"
log "========================================="

# 1. V√©rifier l'espace disque
log "V√©rification de l'espace disque..."
usage=$(df /var/snap/microk8s/common/default-storage | tail -1 | awk '{print $5}' | sed 's/%//')
log "Utilisation: ${usage}%"

if [ $usage -gt 85 ]; then
  log "‚ö†Ô∏è  ALERTE: Espace disque critique"
  # Envoyer une notification
fi

# 2. Lister les PVC non utilis√©s
log "Recherche de PVC non utilis√©s..."
# (utiliser le script find-unused-pvcs.sh)

# 3. Nettoyer les PV Released
log "Nettoyage des PV Released..."
released=$(microk8s kubectl get pv | grep Released | wc -l)
log "PV Released trouv√©s: $released"

# 4. V√©rifier les PVC en Pending
log "V√©rification des PVC en attente..."
pending=$(microk8s kubectl get pvc --all-namespaces | grep Pending | wc -l)
if [ $pending -gt 0 ]; then
  log "‚ö†Ô∏è  $pending PVC en √©tat Pending"
fi

# 5. Rapport
log "R√©sum√©:"
total_pvc=$(microk8s kubectl get pvc --all-namespaces --no-headers | wc -l)
total_pv=$(microk8s kubectl get pv --no-headers | wc -l)
log "  - Total PVC: $total_pvc"
log "  - Total PV: $total_pv"

log "========================================="
log "Fin de la maintenance quotidienne"
log "========================================="
```

## Bonnes pratiques de gestion

### 1. Documentation

Maintenez une documentation √† jour :

```yaml
# Exemple d'annotation compl√®te
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data
  annotations:
    description: "Base de donn√©es PostgreSQL principale"
    owner: "team-backend@example.com"
    created-by: "John Doe"
    purpose: "Production database"
    backup-schedule: "daily at 2AM"
    retention-policy: "90 days"
    cost-center: "engineering"
    disaster-recovery: "RPO: 24h, RTO: 1h"
```

### 2. Naming conventions

Utilisez des conventions de nommage coh√©rentes :

```
<application>-<component>-<environment>-<type>

Exemples:
- webapp-uploads-prod-data
- postgres-main-prod-data
- redis-cache-staging-data
```

### 3. Labels standardis√©s

```yaml
metadata:
  labels:
    app: webapp
    component: database
    environment: production
    tier: data
    backup: "enabled"
    criticality: "high"
```

### 4. Monitoring proactif

- Configurer des alertes avant d'atteindre la capacit√©
- Surveiller les tendances de croissance
- Automatiser les rapports hebdomadaires

### 5. Sauvegardes r√©guli√®res

- Sauvegardes quotidiennes des donn√©es critiques
- Sauvegardes hebdomadaires des autres donn√©es
- Tests de restauration mensuels

### 6. Planification de la capacit√©

```bash
#!/bin/bash
# capacity-planning.sh

# Calculer la croissance moyenne par semaine
echo "Analyse de la capacit√© de stockage"
echo "==================================="

# Total actuel
current_total=$(microk8s kubectl get pvc --all-namespaces -o json | \
  jq -r '.items[].spec.resources.requests.storage' | \
  sed 's/Gi//' | awk '{sum+=$1} END {print sum}')

echo "Capacit√© actuelle: ${current_total}Gi"

# Estimer la croissance (exemple simplifi√©)
# Dans un vrai environnement, analyser les donn√©es historiques
growth_rate=10  # 10% par mois
months=6

for i in $(seq 1 $months); do
  current_total=$(echo "$current_total * 1.10" | bc)
  printf "Estimation mois +$i: %.0fGi\n" $current_total
done
```

### 7. Politique de r√©tention

D√©finir des politiques claires :

```yaml
# Politique de r√©tention par environnement
apiVersion: v1
kind: ConfigMap
metadata:
  name: storage-retention-policy
data:
  production: |
    - Sauvegardes quotidiennes: 30 jours
    - Sauvegardes hebdomadaires: 90 jours
    - Sauvegardes mensuelles: 1 an
    - Sauvegardes annuelles: 7 ans

  staging: |
    - Sauvegardes quotidiennes: 7 jours
    - Sauvegardes hebdomadaires: 30 jours

  development: |
    - Sauvegardes hebdomadaires: 7 jours
    - Pas de r√©tention √† long terme
```

## Checklist de gestion

### Quotidienne
- [ ] V√©rifier les alertes de capacit√©
- [ ] V√©rifier les PVC en Pending
- [ ] V√©rifier les √©checs de backup
- [ ] R√©pondre aux demandes de stockage

### Hebdomadaire
- [ ] Ex√©cuter le rapport de monitoring
- [ ] Nettoyer les ressources inutilis√©es
- [ ] V√©rifier l'int√©grit√© des sauvegardes
- [ ] R√©viser l'utilisation par namespace

### Mensuelle
- [ ] Test de restauration
- [ ] Analyse des tendances de croissance
- [ ] R√©vision des politiques de r√©tention
- [ ] Nettoyage des vieilles sauvegardes
- [ ] Audit de s√©curit√©

### Trimestrielle
- [ ] Planification de la capacit√©
- [ ] R√©vision des StorageClasses
- [ ] Optimisation des co√ªts
- [ ] Formation de l'√©quipe

## R√©sum√© des commandes essentielles

```bash
# Monitoring
microk8s kubectl get pvc --all-namespaces
microk8s kubectl get pv
microk8s kubectl describe pvc <name>
df -h /var/snap/microk8s/common/default-storage

# Expansion
microk8s kubectl patch pvc <name> -p '{"spec":{"resources":{"requests":{"storage":"20Gi"}}}}'

# Sauvegarde
microk8s kubectl exec <pod> -- tar czf - /data > backup.tar.gz

# Restauration
cat backup.tar.gz | microk8s kubectl exec -i <pod> -- tar xzf - -C /data

# Nettoyage
microk8s kubectl delete pvc <name>
microk8s kubectl delete pv <name>

# Diagnostic
microk8s kubectl get events --field-selector involvedObject.name=<pvc>
microk8s kubectl logs <pod>
```

## Conclusion

La gestion efficace des volumes persistants est un aspect critique de l'administration Kubernetes. Elle n√©cessite :

- **Vigilance** : Monitoring constant de l'utilisation et des performances
- **Proactivit√©** : Anticipation des besoins en capacit√©
- **Rigueur** : Sauvegardes r√©guli√®res et test√©es
- **Organisation** : Documentation claire et conventions coh√©rentes
- **Automatisation** : Scripts et outils pour r√©duire le travail manuel

Avec MicroK8s et les pratiques d√©crites dans cette section, vous disposez maintenant de tous les outils n√©cessaires pour g√©rer professionnellement votre infrastructure de stockage, que ce soit pour un lab personnel ou un environnement de production.

---

**Points cl√©s √† retenir** :

‚úÖ **Monitoring** : Surveillez proactivement l'utilisation de l'espace
‚úÖ **Sauvegardes** : Automatisez et testez r√©guli√®rement les restaurations
‚úÖ **Expansion** : Augmentez les volumes avant d'atteindre la capacit√© maximale
‚úÖ **Migration** : Sachez d√©placer les donn√©es entre PVC/namespaces/clusters
‚úÖ **Nettoyage** : Identifiez et supprimez r√©guli√®rement les ressources inutilis√©es
‚úÖ **Documentation** : Annotez et labelisez toutes vos ressources
‚úÖ **Automatisation** : Utilisez des scripts pour les t√¢ches r√©p√©titives
‚úÖ **Planification** : Anticipez la croissance future du stockage

‚è≠Ô∏è [StatefulSets : d√©ployer des applications stateful](/06-stockage-persistant/07-statefulsets-deployer-des-applications-stateful.md)
