üîù Retour au [Sommaire](/SOMMAIRE.md)

# 16.7 Secrets Management Avanc√©

## Introduction

Les secrets (mots de passe, cl√©s API, certificats, tokens) sont les donn√©es les plus sensibles de votre infrastructure. Une gestion inad√©quate des secrets peut compromettre toute la s√©curit√© de votre cluster. Cette section explore les solutions avanc√©es pour g√©rer les secrets de mani√®re s√©curis√©e dans Kubernetes.

**Analogie simple :** Si votre cluster Kubernetes est une banque, les secrets sont les codes des coffres-forts. Vous ne voudriez pas √©crire ces codes sur des post-it coll√©s partout dans la banque, ni les laisser dans un tiroir non verrouill√©. Le secrets management avanc√©, c'est avoir un syst√®me de coffres-forts ultra-s√©curis√©s avec contr√¥le d'acc√®s strict et audit.

## Le Probl√®me : Kubernetes Secrets Natifs

### Limitations des Secrets Kubernetes de Base

Les Secrets Kubernetes natifs ont plusieurs probl√®mes :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Secret Kubernetes Natif              ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  ‚ö†Ô∏è Base64 encod√© (‚â† chiffr√©)           ‚îÇ
‚îÇ  ‚ö†Ô∏è Stock√© en clair dans etcd           ‚îÇ
‚îÇ  ‚ö†Ô∏è Visible dans les manifestes YAML    ‚îÇ
‚îÇ  ‚ö†Ô∏è Pas d'audit des acc√®s               ‚îÇ
‚îÇ  ‚ö†Ô∏è Pas de rotation automatique         ‚îÇ
‚îÇ  ‚ö†Ô∏è Doit √™tre versionn√© avec le code    ‚îÇ
‚îÇ  ‚ö†Ô∏è Difficile √† partager entre √©quipes  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### 1. Base64 n'est PAS du Chiffrement

```bash
# Cr√©er un secret
kubectl create secret generic my-password --from-literal=password=SuperSecret123

# Le voir en base64
kubectl get secret my-password -o yaml
# data:
#   password: U3VwZXJTZWNyZXQxMjM=

# D√©coder facilement
echo "U3VwZXJTZWNyZXQxMjM=" | base64 -d
# SuperSecret123
```

**‚ö†Ô∏è Base64 est un encodage, pas du chiffrement !** N'importe qui avec acc√®s au cluster peut d√©coder.

#### 2. Stockage en Clair dans etcd

Par d√©faut, les secrets sont stock√©s **non chiffr√©s** dans etcd (la base de donn√©es de Kubernetes).

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         etcd             ‚îÇ
‚îÇ                          ‚îÇ
‚îÇ  secrets/default/my-pwd  ‚îÇ
‚îÇ  {                       ‚îÇ
‚îÇ    "password":           ‚îÇ
‚îÇ    "SuperSecret123"      ‚îÇ  ‚Üê En clair !
‚îÇ  }                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Risque :** Quiconque acc√®de √† etcd peut lire tous les secrets.

#### 3. Secrets dans Git

```yaml
# secret.yaml (dans Git)
apiVersion: v1
kind: Secret
metadata:
  name: database
stringData:
  password: MyDatabasePassword123  # ‚ö†Ô∏è En clair dans Git !
```

**Probl√®mes :**
- Historique Git conserve les secrets pour toujours
- Toute personne avec acc√®s au repo voit les secrets
- Difficult de r√©voquer l'acc√®s

#### 4. Pas de Rotation Automatique

```
Secret cr√©√© ‚Üí 2020-01-01
              ‚Üì
Toujours le m√™me mot de passe ‚Üí 2024-12-31
                                  ‚Üì
                          ‚ö†Ô∏è Risque accru avec le temps
```

**Bonne pratique :** Rotation r√©guli√®re (tous les 90 jours par exemple).

#### 5. Pas d'Audit

Kubernetes ne trace pas :
- Qui a lu quel secret ?
- Quand ?
- Depuis o√π ?

## Solutions Avanc√©es

### Vue d'Ensemble

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Solutions de Secrets Management                ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  1. Chiffrement etcd (natif K8s)                ‚îÇ
‚îÇ     ‚îî‚îÄ Chiffre les secrets au repos             ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  2. Sealed Secrets (Bitnami)                    ‚îÇ
‚îÇ     ‚îî‚îÄ Chiffre les secrets pour Git             ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  3. External Secrets Operator                   ‚îÇ
‚îÇ     ‚îî‚îÄ Synchronise depuis sources externes      ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  4. HashiCorp Vault                             ‚îÇ
‚îÇ     ‚îî‚îÄ Coffre-fort centralis√©                   ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  5. Cloud Provider KMS                          ‚îÇ
‚îÇ     ‚îî‚îÄ AWS Secrets Manager, GCP Secret Manager  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Solution 1 : Chiffrement etcd

### Activer le Chiffrement des Secrets dans etcd

Cette solution chiffre les secrets **au repos** dans etcd.

#### Configuration

```yaml
# /etc/kubernetes/encryption-config.yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - aescbc:
        keys:
        - name: key1
          secret: c2VjcmV0IGtleSB0aGF0IGlzIDMyIGJ5dGVzIGxvbmc=  # Base64 d'une cl√© 32 bytes
    - identity: {}  # Fallback pour les secrets non chiffr√©s
```

#### √âtapes d'Activation

1. **G√©n√©rer une cl√© de chiffrement :**

```bash
# G√©n√©rer une cl√© al√©atoire de 32 bytes
head -c 32 /dev/urandom | base64
```

2. **Cr√©er le fichier de configuration** (ci-dessus)

3. **Modifier la configuration de l'API Server :**

```yaml
# /etc/kubernetes/manifests/kube-apiserver.yaml
spec:
  containers:
  - command:
    - kube-apiserver
    - --encryption-provider-config=/etc/kubernetes/encryption-config.yaml
    volumeMounts:
    - name: encryption-config
      mountPath: /etc/kubernetes/encryption-config.yaml
      readOnly: true
  volumes:
  - name: encryption-config
    hostPath:
      path: /etc/kubernetes/encryption-config.yaml
      type: File
```

4. **Rechiffrer les secrets existants :**

```bash
# Forcer la r√©√©criture de tous les secrets
kubectl get secrets --all-namespaces -o json | \
  kubectl replace -f -
```

### Avantages et Limites

**Avantages :**
- ‚úÖ Natif Kubernetes
- ‚úÖ Chiffrement au repos
- ‚úÖ Pas d'outil externe

**Limites :**
- ‚ö†Ô∏è Toujours en base64 dans les manifestes
- ‚ö†Ô∏è Cl√© de chiffrement doit √™tre s√©curis√©e
- ‚ö†Ô∏è Pas de rotation automatique
- ‚ö†Ô∏è Complexe √† configurer

### Dans MicroK8s

MicroK8s utilise Dqlite au lieu d'etcd. Le chiffrement peut √™tre configur√© mais n√©cessite des √©tapes sp√©cifiques.

**Recommandation :** Pour MicroK8s, pr√©f√©rez les solutions externes (Sealed Secrets, Vault).

## Solution 2 : Sealed Secrets

### Concept

Sealed Secrets permet de chiffrer les secrets de mani√®re asym√©trique pour les stocker en toute s√©curit√© dans Git.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Workflow Sealed Secrets           ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  1. Secret en clair                      ‚îÇ
‚îÇ     ‚Üì                                    ‚îÇ
‚îÇ  2. Chiffr√© avec cl√© publique            ‚îÇ
‚îÇ     ‚Üí SealedSecret                       ‚îÇ
‚îÇ     ‚Üì                                    ‚îÇ
‚îÇ  3. Stock√© dans Git (s√©curis√©)           ‚îÇ
‚îÇ     ‚Üì                                    ‚îÇ
‚îÇ  4. Appliqu√© au cluster                  ‚îÇ
‚îÇ     ‚Üì                                    ‚îÇ
‚îÇ  5. Controller d√©chiffre avec cl√© priv√©e ‚îÇ
‚îÇ     ‚Üí Secret Kubernetes                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Principe :** Seul le cluster peut d√©chiffrer les SealedSecrets.

### Installation

```bash
# Installer le controller dans le cluster
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# V√©rifier l'installation
kubectl get pods -n kube-system | grep sealed-secrets

# Installer kubeseal (outil CLI)
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-linux-amd64
chmod +x kubeseal-linux-amd64
sudo mv kubeseal-linux-amd64 /usr/local/bin/kubeseal
```

### Utilisation

#### Cr√©er un SealedSecret

```bash
# Cr√©er un secret (ne pas l'appliquer)
kubectl create secret generic my-secret \
  --from-literal=password=SuperSecret123 \
  --dry-run=client -o yaml > secret.yaml

# Sceller le secret
kubeseal -f secret.yaml -w sealed-secret.yaml

# Le fichier sealed-secret.yaml est maintenant s√ªr pour Git
cat sealed-secret.yaml
```

**R√©sultat :**
```yaml
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: my-secret
  namespace: default
spec:
  encryptedData:
    password: AgBxK8z7... (tr√®s long texte chiffr√©)
  template:
    metadata:
      name: my-secret
```

#### Appliquer au Cluster

```bash
# Appliquer le SealedSecret
kubectl apply -f sealed-secret.yaml

# Le controller cr√©e automatiquement le Secret
kubectl get secret my-secret
```

#### Workflow Complet

```bash
# 1. D√©veloppeur cr√©e un secret
echo -n "SuperSecret123" | kubectl create secret generic db-password \
  --from-file=password=/dev/stdin \
  --dry-run=client -o yaml > secret.yaml

# 2. Sceller le secret
kubeseal -f secret.yaml -w sealed-secret.yaml

# 3. Committer dans Git
git add sealed-secret.yaml
git commit -m "Add database password (sealed)"
git push

# 4. GitOps (ArgoCD/Flux) d√©ploie automatiquement
# Ou manuellement :
kubectl apply -f sealed-secret.yaml

# 5. Le secret est disponible
kubectl get secret db-password -o jsonpath='{.data.password}' | base64 -d
```

### Rotation de la Cl√©

Par d√©faut, Sealed Secrets rotationne sa cl√© tous les 30 jours.

```bash
# Voir les cl√©s
kubectl get secrets -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key=active

# Forcer une rotation manuelle
kubectl delete secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key=active
kubectl rollout restart deployment -n kube-system sealed-secrets-controller
```

**Important :** Apr√®s rotation, vous devez re-sceller tous vos secrets.

### Backup de la Cl√©

```bash
# Sauvegarder la cl√© priv√©e (critique !)
kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key=active -o yaml > sealed-secrets-key.yaml

# Restaurer sur un nouveau cluster
kubectl apply -f sealed-secrets-key.yaml
```

### Avantages et Limites

**Avantages :**
- ‚úÖ Secrets s√©curis√©s dans Git
- ‚úÖ GitOps friendly
- ‚úÖ Simple √† utiliser
- ‚úÖ Pas de d√©pendance externe

**Limites :**
- ‚ö†Ô∏è Rotation manuelle n√©cessaire apr√®s rotation de cl√©
- ‚ö†Ô∏è La cl√© priv√©e du cluster doit √™tre sauvegard√©e
- ‚ö†Ô∏è Pas de rotation automatique des secrets eux-m√™mes

## Solution 3 : External Secrets Operator

### Concept

External Secrets Operator (ESO) synchronise des secrets depuis des sources externes vers Kubernetes.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Sources Externes                          ‚îÇ
‚îÇ                                             ‚îÇ
‚îÇ   ‚Ä¢ HashiCorp Vault                         ‚îÇ
‚îÇ   ‚Ä¢ AWS Secrets Manager                     ‚îÇ
‚îÇ   ‚Ä¢ Azure Key Vault                         ‚îÇ
‚îÇ   ‚Ä¢ GCP Secret Manager                      ‚îÇ
‚îÇ   ‚Ä¢ 1Password                               ‚îÇ
‚îÇ   ‚Ä¢ etc.                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   External Secrets Operator            ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ   ‚Ä¢ R√©cup√®re les secrets               ‚îÇ
‚îÇ   ‚Ä¢ Cr√©e des Secrets Kubernetes        ‚îÇ
‚îÇ   ‚Ä¢ Synchronise automatiquement        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Secrets Kubernetes                   ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ   Utilisables par les pods             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Installation

```bash
# Avec Helm
helm repo add external-secrets https://charts.external-secrets.io
helm install external-secrets external-secrets/external-secrets -n external-secrets-system --create-namespace

# V√©rifier
kubectl get pods -n external-secrets-system
```

### Configuration avec Vault (Exemple)

#### 1. Cr√©er un SecretStore

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-backend
  namespace: default
spec:
  provider:
    vault:
      server: "https://vault.example.com"
      path: "secret"
      version: "v2"
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "my-role"
```

#### 2. Cr√©er un ExternalSecret

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: database-credentials
  namespace: default
spec:
  refreshInterval: 1h  # Synchroniser toutes les heures
  secretStoreRef:
    name: vault-backend
    kind: SecretStore
  target:
    name: database-secret  # Nom du Secret K8s cr√©√©
    creationPolicy: Owner
  data:
  - secretKey: password      # Cl√© dans le Secret K8s
    remoteRef:
      key: database/prod     # Chemin dans Vault
      property: password     # Propri√©t√© dans Vault
  - secretKey: username
    remoteRef:
      key: database/prod
      property: username
```

#### 3. Le Secret est Cr√©√© Automatiquement

```bash
# ESO cr√©e le secret
kubectl get secret database-secret

# Utiliser dans un pod
kubectl get secret database-secret -o jsonpath='{.data.password}' | base64 -d
```

### Configuration avec AWS Secrets Manager

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets
  namespace: default
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: app-secrets
spec:
  refreshInterval: 15m
  secretStoreRef:
    name: aws-secrets
    kind: SecretStore
  target:
    name: app-secrets
  data:
  - secretKey: api-key
    remoteRef:
      key: prod/api-credentials
      property: api_key
```

### Avantages et Limites

**Avantages :**
- ‚úÖ Source de v√©rit√© unique externe
- ‚úÖ Rotation automatique possible
- ‚úÖ Supporte de nombreux providers
- ‚úÖ Audit centralis√©
- ‚úÖ Partage facile entre √©quipes

**Limites :**
- ‚ö†Ô∏è D√©pendance √† un service externe
- ‚ö†Ô∏è Configuration initiale complexe
- ‚ö†Ô∏è Co√ªt potentiel du service externe

## Solution 4 : HashiCorp Vault

### Concept

Vault est un coffre-fort pour secrets avec fonctionnalit√©s avanc√©es.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        HashiCorp Vault                ‚îÇ
‚îÇ                                       ‚îÇ
‚îÇ  ‚Ä¢ Stockage centralis√©                ‚îÇ
‚îÇ  ‚Ä¢ Chiffrement                        ‚îÇ
‚îÇ  ‚Ä¢ Rotation automatique               ‚îÇ
‚îÇ  ‚Ä¢ Audit d√©taill√©                     ‚îÇ
‚îÇ  ‚Ä¢ G√©n√©ration dynamique de secrets    ‚îÇ
‚îÇ  ‚Ä¢ TTL (Time To Live)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
            ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Kubernetes (via Vault Agent)        ‚îÇ
‚îÇ                                       ‚îÇ
‚îÇ   Secrets inject√©s automatiquement    ‚îÇ
‚îÇ   dans les pods                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Installation de Vault

#### Avec Helm

```bash
# Ajouter le repo Helm
helm repo add hashicorp https://helm.releases.hashicorp.com

# Installer Vault
helm install vault hashicorp/vault \
  --set "server.dev.enabled=true" \
  --namespace vault \
  --create-namespace

# V√©rifier
kubectl get pods -n vault
```

#### Mode D√©veloppement (‚ö†Ô∏è Pas pour la production)

```bash
# Vault en mode dev
kubectl exec -it vault-0 -n vault -- /bin/sh

# √Ä l'int√©rieur du pod
vault status
vault secrets enable -path=secret kv-v2
vault kv put secret/database/config username="admin" password="SuperSecret123"
```

### Int√©gration avec Kubernetes

#### M√©thode 1 : Vault Agent Injector

**Annotation dans le pod :**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
  annotations:
    vault.hashicorp.com/agent-inject: "true"
    vault.hashicorp.com/role: "myapp"
    vault.hashicorp.com/agent-inject-secret-database: "secret/data/database/config"
    vault.hashicorp.com/agent-inject-template-database: |
      {{- with secret "secret/data/database/config" -}}
      username={{ .Data.data.username }}
      password={{ .Data.data.password }}
      {{- end }}
spec:
  serviceAccountName: app
  containers:
  - name: app
    image: my-app:latest
    command:
    - sh
    - -c
    - |
      cat /vault/secrets/database
      # Le secret est disponible dans /vault/secrets/database
```

**Configuration Vault :**

```bash
# Activer Kubernetes auth
vault auth enable kubernetes

# Configurer
vault write auth/kubernetes/config \
  kubernetes_host="https://kubernetes.default.svc"

# Cr√©er une policy
vault policy write myapp-policy - <<EOF
path "secret/data/database/config" {
  capabilities = ["read"]
}
EOF

# Cr√©er un r√¥le
vault write auth/kubernetes/role/myapp \
  bound_service_account_names=app \
  bound_service_account_namespaces=default \
  policies=myapp-policy \
  ttl=24h
```

#### M√©thode 2 : Vault CSI Provider

Monter les secrets comme volumes :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  serviceAccountName: app
  containers:
  - name: app
    image: my-app:latest
    volumeMounts:
    - name: secrets
      mountPath: /mnt/secrets
      readOnly: true
  volumes:
  - name: secrets
    csi:
      driver: secrets-store.csi.k8s.io
      readOnly: true
      volumeAttributes:
        secretProviderClass: vault-secrets
```

```yaml
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: vault-secrets
spec:
  provider: vault
  parameters:
    vaultAddress: "http://vault.vault.svc:8200"
    roleName: "myapp"
    objects: |
      - objectName: "database-password"
        secretPath: "secret/data/database/config"
        secretKey: "password"
```

### Secrets Dynamiques

Vault peut g√©n√©rer des secrets √† la demande :

```bash
# Activer le moteur de base de donn√©es
vault secrets enable database

# Configurer PostgreSQL
vault write database/config/postgresql \
  plugin_name=postgresql-database-plugin \
  allowed_roles="app-role" \
  connection_url="postgresql://{{username}}:{{password}}@postgres:5432/mydb" \
  username="vault" \
  password="vault-password"

# Cr√©er un r√¥le avec TTL
vault write database/roles/app-role \
  db_name=postgresql \
  creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}';" \
  default_ttl="1h" \
  max_ttl="24h"

# G√©n√©rer des credentials
vault read database/creds/app-role
# Key                Value
# ---                -----
# lease_id           database/creds/app-role/abc123
# lease_duration     1h
# username           v-app-role-xyz789
# password           A1b2C3d4E5f6
```

**Avantage :** Credentials uniques par pod, rotation automatique, r√©vocation instantan√©e.

### Avantages et Limites

**Avantages :**
- ‚úÖ Solution compl√®te et mature
- ‚úÖ G√©n√©ration dynamique de secrets
- ‚úÖ Rotation automatique
- ‚úÖ Audit d√©taill√©
- ‚úÖ TTL et r√©vocation
- ‚úÖ Haute disponibilit√© possible

**Limites :**
- ‚ö†Ô∏è Complexit√© de d√©ploiement et gestion
- ‚ö†Ô∏è N√©cessite expertise
- ‚ö†Ô∏è Infrastructure suppl√©mentaire
- ‚ö†Ô∏è Co√ªt de licence (version enterprise)

## Solution 5 : Cloud Provider KMS

### AWS Secrets Manager

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: app-config
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore
  target:
    name: app-config
  dataFrom:
  - extract:
      key: prod/app/config  # ARN ou nom du secret
```

**Avantages :**
- ‚úÖ Int√©gration native AWS
- ‚úÖ Rotation automatique
- ‚úÖ Chiffrement KMS
- ‚úÖ Audit CloudTrail

### Google Secret Manager

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: gcp-secrets
spec:
  provider:
    gcpsm:
      projectID: "my-project"
      auth:
        workloadIdentity:
          clusterLocation: us-central1
          clusterName: my-cluster
          serviceAccountRef:
            name: external-secrets
---
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: app-secrets
spec:
  refreshInterval: 15m
  secretStoreRef:
    name: gcp-secrets
  target:
    name: app-secrets
  data:
  - secretKey: api-key
    remoteRef:
      key: projects/123456789/secrets/api-key/versions/latest
```

### Azure Key Vault

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: azure-keyvault
spec:
  provider:
    azurekv:
      vaultUrl: "https://my-vault.vault.azure.net"
      authType: ManagedIdentity
      identityId: "/subscriptions/.../resourceGroups/.../providers/Microsoft.ManagedIdentity/userAssignedIdentities/..."
```

## Bonnes Pratiques

### 1. Ne Jamais Committer de Secrets en Clair

```bash
# ‚ùå Mauvais
git add secret.yaml  # Contient des secrets en clair

# ‚úÖ Bon
git add sealed-secret.yaml  # Secret chiffr√©
# Ou
git add external-secret.yaml  # R√©f√©rence externe
```

**Outil de pr√©vention :**

```bash
# Installer git-secrets
git clone https://github.com/awslabs/git-secrets
cd git-secrets
sudo make install

# Configurer dans votre repo
cd /path/to/repo
git secrets --install
git secrets --register-aws
```

### 2. Rotation R√©guli√®re

```yaml
# Politique de rotation recommand√©e
Secrets critiques (DB, API keys) : 90 jours
Secrets sensibles (tokens) : 180 jours
Certificats : Avant expiration
```

**Automatisation avec Vault :**

```bash
# Secret avec TTL
vault kv put -mount=secret database/prod \
  password="SuperSecret123" \
  ttl=90d
```

### 3. Principe du Moindre Privil√®ge

```yaml
# ‚ùå Mauvais : Tous les secrets dans un seul Secret
apiVersion: v1
kind: Secret
metadata:
  name: all-secrets
data:
  db-password: ...
  api-key: ...
  admin-token: ...

# ‚úÖ Bon : Un Secret par service/composant
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
data:
  password: ...
---
apiVersion: v1
kind: Secret
metadata:
  name: api-credentials
data:
  api-key: ...
```

**Avec RBAC :**

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-role
rules:
- apiGroups: [""]
  resources: ["secrets"]
  resourceNames: ["database-credentials"]  # Seulement ce secret
  verbs: ["get"]
```

### 4. Audit et Monitoring

```yaml
# Activer l'audit des acc√®s aux secrets
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: RequestResponse
  resources:
  - group: ""
    resources: ["secrets"]
  verbs: ["get", "list", "watch"]
```

**Avec Vault :**

```bash
# Activer l'audit
vault audit enable file file_path=/vault/audit.log

# Voir les acc√®s
vault audit list
```

### 5. S√©parer les Environnements

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Dev                                ‚îÇ
‚îÇ  ‚îî‚îÄ Secrets de dev (moins sensibles)‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  Staging                            ‚îÇ
‚îÇ  ‚îî‚îÄ Secrets de staging              ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ  Production                         ‚îÇ
‚îÇ  ‚îî‚îÄ Secrets de prod (haute s√©curit√©)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Avec namespaces :**

```bash
# Secrets dev
kubectl create secret generic db-password \
  --from-literal=password=dev123 \
  -n dev

# Secrets prod (plus s√©curis√©)
kubectl create secret generic db-password \
  --from-literal=password=$(vault kv get -field=password secret/prod/database) \
  -n production
```

### 6. Chiffrement en Transit

```yaml
# Toujours utiliser TLS/HTTPS
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  DATABASE_URL: "postgresql://user:pass@postgres.example.com:5432/db?sslmode=require"
  #                                                                    ^^^^^^^^^^^^^^^^
  #                                                                    TLS activ√©
```

### 7. Limiter l'Acc√®s aux Secrets

```yaml
# ServiceAccount d√©di√©
apiVersion: v1
kind: ServiceAccount
metadata:
  name: app-sa
  namespace: production
---
# Role limit√©
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-reader
  namespace: production
rules:
- apiGroups: [""]
  resources: ["secrets"]
  resourceNames: ["app-secret"]  # Uniquement ce secret
  verbs: ["get"]
---
# RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-secret-binding
  namespace: production
subjects:
- kind: ServiceAccount
  name: app-sa
roleRef:
  kind: Role
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
```

### 8. Scanner les Secrets dans les Images

```bash
# Avec Trivy
trivy image --scanners secret my-app:latest

# Avec truffleHog
docker run --rm -it trufflesecurity/trufflehog:latest \
  docker --image my-app:latest
```

### 9. Utiliser des Init Containers

Charger les secrets avant le d√©marrage de l'application :

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app
spec:
  initContainers:
  - name: secret-loader
    image: vault:latest
    command:
    - sh
    - -c
    - |
      # R√©cup√©rer le secret depuis Vault
      vault kv get -field=password secret/database > /secrets/db-password
    volumeMounts:
    - name: secrets
      mountPath: /secrets
  containers:
  - name: app
    image: my-app:latest
    volumeMounts:
    - name: secrets
      mountPath: /secrets
      readOnly: true
  volumes:
  - name: secrets
    emptyDir: {}
```

### 10. Documentation

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-credentials
  annotations:
    description: "Credentials for external API"
    owner: "team-backend"
    rotation-schedule: "Every 90 days"
    last-rotation: "2024-01-15"
    next-rotation: "2024-04-15"
    source: "HashiCorp Vault: secret/prod/api"
```

## Comparaison des Solutions

| Solution | Complexit√© | Co√ªt | Rotation Auto | GitOps | Audit | Recommand√© Pour |
|----------|------------|------|---------------|--------|-------|-----------------|
| **etcd Encryption** | Moyenne | Gratuit | ‚ùå | ‚ùå | ‚ùå | Am√©lioration de base |
| **Sealed Secrets** | Faible | Gratuit | ‚ùå | ‚úÖ | ‚ùå | Petites √©quipes, GitOps |
| **External Secrets** | Moyenne | Variable | ‚úÖ | ‚úÖ | ‚úÖ | Int√©gration cloud |
| **Vault** | √âlev√©e | Gratuit/Payant | ‚úÖ | ‚ö†Ô∏è | ‚úÖ | Grandes organisations |
| **Cloud KMS** | Faible | Payant | ‚úÖ | ‚úÖ | ‚úÖ | Si d√©j√† sur le cloud |

## Impl√©mentation dans MicroK8s

### Sealed Secrets (Recommand√© pour Commencer)

```bash
# Installation
kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml

# V√©rification
microk8s kubectl get pods -n kube-system | grep sealed-secrets

# Installer kubeseal
wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/kubeseal-linux-amd64
chmod +x kubeseal-linux-amd64
sudo mv kubeseal-linux-amd64 /usr/local/bin/kubeseal

# Utilisation
echo -n "SuperSecret123" | kubectl create secret generic my-secret \
  --from-file=password=/dev/stdin \
  --dry-run=client -o yaml | \
  kubeseal -o yaml > sealed-secret.yaml

microk8s kubectl apply -f sealed-secret.yaml
```

### External Secrets Operator

```bash
# Installer avec Helm
microk8s enable helm3

# Ajouter le repo
microk8s helm3 repo add external-secrets https://charts.external-secrets.io

# Installer
microk8s helm3 install external-secrets \
  external-secrets/external-secrets \
  -n external-secrets-system \
  --create-namespace

# V√©rifier
microk8s kubectl get pods -n external-secrets-system
```

### Vault en Mode Dev

```bash
# Installer Vault
microk8s helm3 repo add hashicorp https://helm.releases.hashicorp.com

microk8s helm3 install vault hashicorp/vault \
  --set "server.dev.enabled=true" \
  --namespace vault \
  --create-namespace

# Acc√©der √† Vault
microk8s kubectl exec -it vault-0 -n vault -- /bin/sh
vault status
```

## Workflow Recommand√©

### Pour une Petite √âquipe

```
1. D√©veloppement local
   ‚îî‚îÄ Secrets en variables d'environnement locales

2. Git
   ‚îî‚îÄ Sealed Secrets (chiffr√©s)

3. CI/CD
   ‚îî‚îÄ D√©crypte et d√©ploie les Sealed Secrets

4. Cluster
   ‚îî‚îÄ Controller Sealed Secrets cr√©e les Secrets K8s
```

### Pour une Grande Organisation

```
1. D√©veloppement local
   ‚îî‚îÄ Variables d'environnement ou Vault dev

2. Git
   ‚îî‚îÄ ExternalSecrets manifests (pas de secrets)

3. Vault / Cloud KMS
   ‚îî‚îÄ Source de v√©rit√© centralis√©e

4. Cluster
   ‚îî‚îÄ External Secrets Operator synchronise depuis Vault

5. Applications
   ‚îî‚îÄ Utilisent les Secrets K8s cr√©√©s automatiquement
```

## Checklist Secrets Management

Avant de d√©ployer en production :

- [ ] Secrets jamais en clair dans Git
- [ ] Solution de chiffrement en place (Sealed Secrets minimum)
- [ ] Rotation des secrets planifi√©e (90-180 jours)
- [ ] RBAC stricte sur les secrets
- [ ] Audit des acc√®s aux secrets activ√©
- [ ] Secrets s√©par√©s par environnement
- [ ] TLS/HTTPS partout
- [ ] Scanner les images pour secrets expos√©s
- [ ] Backup des cl√©s de chiffrement
- [ ] Documentation des secrets (sans les valeurs)
- [ ] Plan de r√©vocation en cas de compromission
- [ ] Formation de l'√©quipe

## Sc√©nario de Compromission

### Si un Secret est Compromis

```
1. IDENTIFICATION
   ‚îî‚îÄ Quel secret ? Quelle port√©e ?

2. R√âVOCATION IMM√âDIATE
   ‚îî‚îÄ R√©voquer le secret compromis
   ‚îî‚îÄ G√©n√©rer un nouveau secret

3. ROTATION
   ‚îî‚îÄ Mettre √† jour dans Vault/KMS
   ‚îî‚îÄ External Secrets synchronise automatiquement
   ‚îî‚îÄ Ou red√©ployer les Sealed Secrets

4. INVESTIGATION
   ‚îî‚îÄ Comment le secret a-t-il √©t√© compromis ?
   ‚îî‚îÄ Audit logs pour voir les acc√®s

5. AM√âLIORATION
   ‚îî‚îÄ Corriger la faille
   ‚îî‚îÄ Am√©liorer les processus
```

**Exemple avec Vault :**

```bash
# R√©voquer le lease d'un secret dynamique
vault lease revoke database/creds/app-role/abc123

# Reg√©n√©rer un nouveau secret
vault kv put secret/database/prod password="NewSuperSecret456"

# External Secrets synchronise automatiquement
# (selon refreshInterval configur√©)
```

## Conclusion

Le secrets management est crucial pour la s√©curit√© :

1. **Ne jamais** stocker de secrets en clair dans Git
2. **Chiffrer** les secrets au repos et en transit
3. **Rotate** r√©guli√®rement (90-180 jours)
4. **Auditer** les acc√®s aux secrets
5. **Limiter** l'acc√®s selon le principe du moindre privil√®ge

**Formule Secrets Management :**
```
S√©curit√© = Chiffrement + Rotation + Audit + Moindre Privil√®ge
```

**Points Cl√©s √† Retenir :**

- Base64 ‚â† Chiffrement
- Kubernetes Secrets natifs ont des limitations importantes
- **Sealed Secrets** : Solution simple pour GitOps
- **External Secrets** : Int√©gration avec sources externes (Vault, AWS, etc.)
- **Vault** : Solution compl√®te pour grandes organisations
- Rotation automatique quand possible
- RBAC stricte sur les secrets
- Audit de tous les acc√®s
- S√©parer dev/staging/production
- Scanner les images pour secrets expos√©s

**Recommandations par Contexte :**

- **Lab personnel / Apprentissage** : Sealed Secrets
- **Petite √©quipe / Startup** : Sealed Secrets + External Secrets
- **Moyenne entreprise** : External Secrets + Cloud KMS
- **Grande entreprise** : HashiCorp Vault + External Secrets

**Prochaines √âtapes :**

Dans les sections suivantes, nous explorerons :
- **16.8** : Audit logging
- **16.9** : Bonnes pratiques de s√©curit√©
- **16.10** : Checklist de s√©curit√© compl√®te

Le secrets management, combin√© avec toutes les autres couches de s√©curit√© (RBAC, Network Policies, Pod Security, Scan d'images), compl√®te votre strat√©gie de d√©fense en profondeur pour Kubernetes.

‚è≠Ô∏è [Audit logging](/16-securite-kubernetes/08-audit-logging.md)
